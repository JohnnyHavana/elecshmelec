//     $Date: 2018-03-26 08:32:18 +1100 (Mon, 26 Mar 2018) $
// $Revision: 1217 $
//   $Author: Peter $

#include "Ass-02.h"
#include "Ass-02-Q01.h"
#include <math.h>
#include <stdlib.h>


#ifdef STM32F407xx
#include "usart.h"
#endif


uint8_t debugOn = 0;
int wordCount = 0;
char **array_of_words;
char* newString;
int length = 10;
int stringIndex = 0;
uint8_t buildInputStringFirstTime = 1;


typedef struct {
	  int startX;
	  int startY;
	  int width;
	  int height;
	  int buttonPressed;
	  char* text;
	  int id;
}Button;


static Button buttons[20];
char *textArray[] = {"7","8","9","+","-","4","5","6","/","*","1","2","3","sqrt","+-","0",".","clr","pow","="};

char* inputString;
char* outputString;

static int inputStringIndex = 0;
static int decimalPointPlaced = 0;
static int firstTime = 1;
static int equalsPressed = 0;


void analyseTouch(Button currentButtonPressed);
void concatenateButtonText(char* buttonText);
double doEquals();
double doEquals2();

int isOperator(char);
int maxSize = 20;

float compute(char operator,char* leftNum,char* rightNum);
Button buildButton(int x , int y, int w, int h, int id);



#ifndef MECOMMANDLIST
#define MECOMMANDLIST
const command_s commandList[] = {
		{"add",  &validateAddition, "add <num 1> .. <num N>\n"},
		{"sub",  &validateSubtraction, "sub <num 1> <num 2>\n"},
		{"mul",  &validateMultiplication, "mul <num 1> .. <num N>\n"},
		{"div",  &validateDivision, "div <num 1> <num 2>\n"},
//		{"sqrt", &validateSquareRoot, "sqrt <num1> : Finds the square root of a floating point number.\n"},
//		{"cbrt", &validateCubeRoot,"cbrt <num1> : Finds the cube root of a floating point number.\n"},
//		{"pow",  &validatePower,"pow <num1> <num2> : Finds the power of the num1 to the power of num2.\n"},
//		{"mod",  &validateModulo,"mod <num1> <num2>: Finds the modulo of two INTEGERS.\n"},
//		{"debug",&debugMode,"debug <on|off> : Turn debug messages on or off.\n"},
//		{"help", &helpDesk,"help [command] : Prints help information for a command\n"},
		{NULL, NULL, NULL}

};
#endif


void printArrayOfWords()
{
	if (wordCount != 0) {
		printf("count = %d\n", wordCount);
		for (int j=0;j<wordCount;j++) {
		  printf("Word(%d): '%s'\n", j+1, (array_of_words)[j]);
		}
	  }
	else
		printf("No words found\n");
}


void freeEverything()
{
	free(newString);
	free(array_of_words);
}


void analyseKeywords(uint8_t argNum, char* argStrings[])
{

	if(argNum == 0)
	{
		printf("Error. No input. Seek help.\n");
		return;
	}

	char* firstKeyword  = (argStrings)[0];

	//must be either add,sub,mul,div
	if(firstKeyword[0] == 'a' && firstKeyword[1] == 'd' && firstKeyword[2] == 'd' && firstKeyword[3] == '\0')
		validateAddition(argNum, argStrings);
	else if(firstKeyword[0] == 's' && firstKeyword[1] == 'u' && firstKeyword[2] == 'b' && firstKeyword[3] == '\0')
		validateSubtraction(argNum, argStrings);
	else if(firstKeyword[0] == 'm' && firstKeyword[1] == 'u' && firstKeyword[2] == 'l' && firstKeyword[3] == '\0')
		validateMultiplication(argNum, argStrings);
	else if(firstKeyword[0] == 'd' && firstKeyword[1] == 'i' && firstKeyword[2] == 'v' && firstKeyword[3] == '\0')
		validateDivision(argNum, argStrings);
	else if(firstKeyword[0] == 'h' && firstKeyword[1] == 'e' && firstKeyword[2] == 'l' && firstKeyword[3] == 'p' && firstKeyword[4] == '\0')
			helpDesk(argNum,argStrings);
	else if(firstKeyword[0] == 'd' && firstKeyword[1] == 'e' && firstKeyword[2] == 'b' && firstKeyword[3] == 'u' && firstKeyword[4] == 'g' && firstKeyword[5] == '\0')
		debugMode(argNum,argStrings);



	//EXTRA FUNCTIONALITY
	else if(firstKeyword[0] == 's' && firstKeyword[1] == 'q' && firstKeyword[2] == 'r' && firstKeyword[3] == 't' && firstKeyword[4] == '\0')
		validateAndRunRoot(0, argNum, argStrings);
	else if(firstKeyword[0] == 'c' && firstKeyword[1] == 'b' && firstKeyword[2] == 'r' && firstKeyword[3] == 't' && firstKeyword[4] == '\0')
		validateAndRunRoot(1,argNum, argStrings);
	else if(firstKeyword[0] == 'p' && firstKeyword[1] == 'o' && firstKeyword[2] == 'w' && firstKeyword[3] == '\0')
		validatePower(argNum, argStrings);
	else if(firstKeyword[0] == 'm' && firstKeyword[1] == 'o' && firstKeyword[2] == 'd' && firstKeyword[3] == '\0')
		validateModulo(argNum, argStrings);


	else
		printf("Error. Unrecognised command. Seek help.\n");

}

float validateSquareRoot(uint8_t argNum, char* argStrings[])
{
	return validateAndRunRoot(0,argNum,argStrings);
}

float validateCubeRoot(uint8_t argNum, char* argStrings[])
{
	return validateAndRunRoot(1,argNum,argStrings);
}

float validateAndRunRoot(uint8_t flag, uint8_t argNum, char* argStrings[])
{
	float result = 0; //sentinel
	if(checkArgumentLength2(1,2, argNum) == 0)
		printf("Error. Must contain only one number for Root.\n");
	else
	{
		if(checkForNumericArgument2(0,argNum, argStrings) == 1)
		{
			//float result;
			if(flag == 0) //sqrt
				result = squareRoot(argStrings);
			else //cbrt
				result = cubeRoot(argStrings);

//			printf("Result: %.2f\n", result);
		}
	}

	return result;
}

float squareRoot(char* argStrings[])
{
	float result = atof(argStrings[1]);
	return sqrtf(result);
}

float cubeRoot(char* argStrings[])
{
	return cbrtf(atof(argStrings[1]));
}

float validatePower(uint8_t argNum, char* argStrings[])
{
	float result = 0;
 	if(checkArgumentLength2(1,3, argNum) == 0)
	{
			printf("Error. Must contain only two numbers for Powers. ");
			(argNum > 3) ? printf("No one man should have all that power.\n") : printf("\n");
	}
	else
	{
		if(checkForNumericArgument2(0,argNum, argStrings) == 1)
		{

			result = power(argStrings);
//			printf("Result: %.2f\n", result);
		}
	}
 	return result;
}

float power(char* argStrings[])
{
	return powf(atof(argStrings[1]),atof(argStrings[2]));
}

float validateModulo(uint8_t argNum, char* argStrings[])
{
	float result = 0;
	if(checkArgumentLength2(1,3,argNum) == 0)
		printf("Error. Must contain only two integers for Modulo.\n");
	else
	{
		if(checkForNumericArgument2(1,argNum,argStrings) == 1)
		{
			result = modulo(argStrings);
//			printf("Result: %.2f\n", result);
		}
	}
	return result;
}

int modulo(char* argStrings[])
{
	return (int)atof(argStrings[1]) % (int)atof(argStrings[2]);
}

uint8_t checkArgumentLength2(uint8_t flag, uint8_t expectedWordCount, uint8_t argNum)
{
	if(argNum == 1)
		return 0;

	if(flag == 0) //used for addition and subtraction. N number of arguments supported
		return 1;
	else //flag must be 1. flag is used in the operations where a number of arguments is specified, i.e sub, div, sqrt, sbrt, mod, pow
	{
		if(argNum < expectedWordCount || argNum > expectedWordCount)
			return 0;
		else
			return 1;

	}
}



uint8_t checkForNumericArgument2(uint8_t processingIntegerFlag,uint8_t argNum, char* argStrings[])
{
	uint8_t foundDecimalPoint = 0;

	for(int i = 1; i < argNum; i++)
	{

		for(int j = 0; argStrings[i][j] != '\0'; j++) //check each letter in the word
		{
			if(argStrings[i][j] == '.')
			{ //searching for decimal point

				if(foundDecimalPoint == 0)
					foundDecimalPoint = 1;
				else
				{
					printf("Error. Not a valid input0\n");
					return 0;
				}
			}

			else if(!((argStrings[i][j] >= 48 && argStrings[i][j] <= 57) || argStrings[i][j] == '-')) //if the number is not within 0-9 (non numeric)
			{
				printf("Error. Not a valid input1\n");
				return 0;
			}

			else if(processingIntegerFlag == 1 && foundDecimalPoint == 1 && (argStrings[i][j] >= 48 && argStrings[i][j] <= 57)) //if a decimal point is found and numerals trail it, it must be a decimal
			{
				printf("Error. Not a valid Input2\n");
				return 0;
			}

		}
		//new word, reset decimal point
		foundDecimalPoint = 0;
	}

	return 1;
}

float validateAddition(uint8_t argNum, char* argStrings[])
{
	float result = 0;
	if(checkArgumentLength2(0,99, argNum) == 0)
		printf("Error. Must contain one or more numbers for addition.\n");
	else
	{
		if(checkForNumericArgument2(0,argNum,argStrings) == 1)
		{
			result = addNumbers(argNum, argStrings);
//			printf("Result: %.2f\n", result);
		}
	}
	return result;
}


float addNumbers(uint8_t argNum, char* argStrings[])
{

	float currentSum = 0;

	for(int i = 1; i < argNum; i++)
	{
		float stringToFloat = atof(argStrings[i]);
		currentSum += stringToFloat;
	}

	return currentSum;
}

float validateSubtraction(uint8_t argNum, char* argStrings[])
{
	float result = 0;
	if(checkArgumentLength2(1,3,argNum) == 0)
		printf("Error. Must contain exactly two numbers for subtraction\n");
	else
	{
		if(checkForNumericArgument2(0,argNum, argStrings) == 1)
		{
			result = subNumbers(argNum, argStrings);
//			printf("Result: %.2f\n", result);
		}
	}
	return result;
}

float subNumbers(uint8_t argNum, char* argStrings[])
{
	float currentSub = 0;
	uint8_t firstRun = 1;
	for(int i = 1; i < argNum; i++)
	{
		float stringToFloat = atof((argStrings)[i]);

		if(firstRun == 1)
		{
			currentSub = stringToFloat;
			firstRun = 0;
		}
		else
			currentSub -= stringToFloat;
	}

	return currentSub;

}

float validateMultiplication(uint8_t argNum, char* argStrings[])
{
	float result = 0;
	if(checkArgumentLength2(0,99,argNum) == 0)
		printf("Error. Must contain one or more numbers for multiplication.\n");
	else
	{
		if(checkForNumericArgument2(0,argNum,argStrings) == 1)
		{
			result = mulNumbers(argNum, argStrings);
//			printf("Result: %.2f\n", result);
		}

	}
	return result;
}

float mulNumbers(uint8_t argNum, char* argStrings[])
{
	float currentMul = 0;
	uint8_t firstTime = 1;
	for(int i = 1; i < argNum; i++)
	{
		float stringToFloat = 0;
		sscanf(argStrings[i],"%f",&stringToFloat);

		//float stringToFloat = atof((argStrings)[i]);

		if(firstTime)
		{
			currentMul = stringToFloat;
			firstTime = 0;

		}
		else
			currentMul *= stringToFloat;
	}

	return currentMul;
}

float validateDivision(uint8_t argNum, char* argStrings[])
{
	float result = 0;
	if(checkArgumentLength2(1,3,argNum) == 0)
		printf("Error. Must contain exactly two numbers for division\n");
	else
	{
		if(checkForNumericArgument2(0,argNum,argStrings) == 1)
		{
			result = divNumbers(argNum,argStrings);
//			printf("Result: %.2f\n", result);
		}
	}
	return result;
}

float divNumbers(uint8_t argNum, char* argStrings[])
{
	float currentDiv = 0;
	uint8_t firstRun = 1;
	for(int i = 1; i < argNum; i++)
	{
		float stringToFloat = atof((argStrings)[i]);
		if(stringToFloat == 0.0)
		{
			return 0.0; //it was always going to be a 0.0 result regardless
		}

		if(firstRun == 1)
		{
			currentDiv = stringToFloat;
			firstRun = 0;
		}
		else
			currentDiv /= stringToFloat;
	}

	return currentDiv;

}


void debugMode(uint8_t argNum, char* argStrings[])
{
	if(argNum < 2)
	{
		printf("##Extended Functionality## \t\t Debug status => %d\n", debugOn);
	}
	else if(argNum > 2)
	{
		printf("Error. Debug command must take zero or one argument. Seek help.\n");
		return;
	}
	else
	{
		char * secondKeyword =  (argStrings)[1];
		if(secondKeyword[0] == 'o' && secondKeyword[1] == 'n' && secondKeyword[2] == '\0')
		{
			if(debugOn == 1)
				printf("Debug is already on.\n");
			else
			{
				debugOn = 1;
				printf("Debug message will be displayed\n");
			}
		}
		else if(secondKeyword[0] == 'o' && secondKeyword[1] == 'f' && secondKeyword[2] == 'f' && secondKeyword[3] == '\0')
		{
			if(debugOn == 0)
				printf("Debug is already off.\n");
			else
			{
				debugOn = 0;
				printf("Debug message will not be displayed");
			}
		}
		else
			printf("Error. Not a valid input for debug keyword. Seek help.");
	}


}

void helpDesk(uint8_t argNum, char* argStrings[])
{
	if(argNum < 2) {
		printf("add <num1> ... <num N> : Sum one or more numbers.\n");
		printf("sub <num1> <num 2> : Subtract two numbers.\n");
		printf("mul <num1> ... <num N> : Multiply one or more numbers.\n");
		printf("div <num1> <num2> : Divide two numbers.\n");
		printf("debug <on|off> : Turn debug messages on or off.\n");
		printf("help [command] : Prints help information for a command\n");

		printf("\n\n##### EXTRA FUNCTIONS #####\n");
		printf("sqrt <num1> : Finds the square root of a floating point number.\n");
		printf("cbrt <num1> : Finds the cube root of a floating point number.\n");
		printf("pow <num1> <num2> : Finds the power of the num1 to the power of num2.\n");
		printf("mod <num1> <num2>: Finds the modulo of two INTEGERS.\n");

	}
	else if(argNum == 2)	{
		char * secondKeyword =  (argStrings)[1];

			if(secondKeyword[0] == 'a' && secondKeyword[1] == 'd' && secondKeyword[2] == 'd' && secondKeyword[3] == '\0')
				printf("add <num1> ... <num N> : Sum one or more numbers.\n");

			else if(secondKeyword[0] == 's' && secondKeyword[1] == 'u' && secondKeyword[2] == 'b' && secondKeyword[3] == '\0')
				printf("sub <num1> <num 2> : Subtract two numbers.\n");

			else if(secondKeyword[0] == 'm' && secondKeyword[1] == 'u' && secondKeyword[2] == 'l' && secondKeyword[3] == '\0')
				printf("mul <num1> ... <num N> : Multiply one or more numbers.\n");

			else if(secondKeyword[0] == 'd' && secondKeyword[1] == 'i' && secondKeyword[2] == 'v' && secondKeyword[3] == '\0')
				printf("div <num1> <num2> : Divide two numbers.\n");
			else if(secondKeyword[0] == 'h' && secondKeyword[1] == 'e' && secondKeyword[2] == 'l' && secondKeyword[3] == 'p' && secondKeyword[4] == '\0')
				printf("help [command] : Prints help information for a command\n");
			else if(secondKeyword[0] == 'd' && secondKeyword[1] == 'e' && secondKeyword[2] == 'b' && secondKeyword[3] == 'u' && secondKeyword[4] == 'g' && secondKeyword[5] == '\0')
				printf("debug <on|off> : Turn debug messages on or off.\n");


			else if(secondKeyword[0] == 's' && secondKeyword[1] == 'q' && secondKeyword[2] == 'r' && secondKeyword[3] == 't' && secondKeyword[4] == '\0')
				printf("sqrt <num1> : Finds the square root of a floating point number.\n");
			else if(secondKeyword[0] == 'c' && secondKeyword[1] == 'b' && secondKeyword[2] == 'r' && secondKeyword[3] == 't' && secondKeyword[4] == '\0')
				printf("cbrt <num1> : Finds the cube root of a floating point number.\n");
			else if(secondKeyword[0] == 'p' && secondKeyword[1] == 'o' && secondKeyword[2] == 'w' && secondKeyword[3] == '\0')
				printf("pow <num1> <num2> : Finds the power of the num1 to the power of num2.\n");
			else if(secondKeyword[0] == 'm' && secondKeyword[1] == 'o' && secondKeyword[2] == 'd' && secondKeyword[3] == '\0')
				printf("mod <num1> <num2>: Finds the modulo of two INTEGERS.\n");


			else
				printf("Error. Unrecognised command. Seek help.\n");
	}
	else
		printf("Error. Unrecognised command. Seek help\n");
}


void CommandLineParserInit(void)
{
  // Print welcome message
//  printf("\014"); //this is a form feed
  printf("ELEC3730 Assignment 2\n");
//  printf("Command Line Parser Example\n");
}


void CommandLineParserProcess(void)
{
  uint8_t c;


  // Check for input and echo back
#ifdef STM32F407xx
  if (HAL_UART_Receive(&huart2, &c, 1, 0x0) == HAL_OK) //code for running through stm board
  {
    HAL_GPIO_TogglePin(GPIOD, LD4_Pin); // Toggle LED4

    	char c;
    	int i;
        char command_line[101];

    	// Get one line of input
    	printf("--> Question 1 - Enter text:\n");
    	i=0;
    	c=getchar();
    	while (c != 13 && i < 100)
    	{
    		printf("%c",c);
    		command_line[i]=c;
    		i++;
    	    c=getchar();
    	}
    	printf("\n");
    	command_line[i]=0;

    	// Parse the input and print result
      	wordCount = string_parser(command_line, &array_of_words);
      	if(debugOn == 1) printArrayOfWords();
      	analyseKeywords(wordCount, array_of_words);
      	freeEverything();

  }
#else
  c = getchar();
  //printf("SERIAL: Got '%c' or in ascii '%d'\n", c,c);
  buildInputString(c);

#endif
}







void buildInputString(uint8_t c){
	if(buildInputStringFirstTime == 1)	  {
	  newString = (char*)malloc(sizeof(char*) * length); //start of string. will have reallocation of memory if string is longer
	  buildInputStringFirstTime = 0; //now not the first run through
	  if(c == '\0' || c == 10) {
		  newString[stringIndex] = '\0';

		  wordCount = string_parser(newString, &array_of_words);

		  printArrayOfWords();

		  for(int i = 0 ; i < 5; i++)
		  {
			  for(int j = 0 ; j < 4 ;j++)
			  {
				  buttons[j * 5 + i] = buildButton(64* i, 80 + 40*j, 64,40,j* 5 + i);
				  //showButton(buttons[j*5+i]);
				  //buttonToString(buttons[j*5+i]);
			  }
		  }

		  for(int i = 0; i< 20; i++)
		  {
			  printf("%s, %d\n", buttons[i].text, buttons[i].id);
		  }
		  //printf("DEBUG: word count -> %d", wordCount);
		  //analyseKeywords(wordCount, array_of_words);

		  Button currentButtonPressed;
		  char* buttonID = array_of_words[0];
		  int buttonIDToInt = atoi(buttonID);
		  for(int i = 0 ;i < 20; i++)
		  {
			  if(buttonIDToInt == buttons[i].id)
				  currentButtonPressed = buttons[i];
		  }

		  analyseTouch(currentButtonPressed);

		  freeEverything();

		  //printNewString();
		  buildInputStringFirstTime = 1; //reset
		  length = 10;
	  }
	  else{
		  newString[stringIndex] = c;
		  stringIndex++;

	  }

	}
	else{
		newString = (char*)realloc(newString, sizeof(newString)+1);

		if(c == '\0' || c == 10){
		  newString[stringIndex] = '\0';

		  wordCount = string_parser(newString, &array_of_words);
		  printArrayOfWords();

		  for(int i = 0 ; i < 5; i++)
		  {
			  for(int j = 0 ; j < 4 ;j++)
			  {
				  buttons[j * 5 + i] = buildButton(64* i, 80 + 40*j, 64,40,j* 5 + i);
				  //showButton(buttons[j*5+i]);
				  //buttonToString(buttons[j*5+i]);
			  }
		  }

		  for(int i = 0; i< 20; i++)
		  {
			  printf("%s, %d\n", buttons[i].text, buttons[i].id);
		  }

		  //analyseKeywords(wordCount, array_of_words);

		  Button currentButtonPressed;
		  char* buttonID = array_of_words[0];
		  int buttonIDToInt = atoi(buttonID);
		  for(int i = 0 ;i < 20; i++)
		  {
			  if(buttonIDToInt == buttons[i].id)
				  currentButtonPressed = buttons[i];
		  }

		  analyseTouch(currentButtonPressed);
		  freeEverything();


		  buildInputStringFirstTime = 1; //reset
		  stringIndex = 0; //reset

		}
		else{
		  newString[stringIndex] = c;
		  stringIndex++;
		  if(stringIndex == length)
		  {
			  length *=2;
			  newString = (char*)realloc(newString,sizeof(char*) * length);
		  }
		}
	}
}

int string_parser(char *inp, char **array_of_words_p[])
{
	/**********************************SETUP**********************************/

	int numberOfWords = 0;
	int currentWordLength = 0;

	//If input is an empty string, returns straight away
	if(inp[0] == '\0')
		return 0;

	int lengthOfInput = 1; //start from 1 for null terminator
	for(int i = 0; inp[i] != '\0';i++)
		lengthOfInput++;

	//Allocate memory, take into account backspaces for now
	char* convertedInput = (char*)malloc((size_t)lengthOfInput * sizeof(char)); //null terminator

	/**********************************REMOVING BACKSPACES**********************************/
	int reader = 0; //Reading inp variable
	int writer = 0; //Writing to converted Input
	while(inp[reader] != '\0') {
		if(inp[reader] == 127 || inp[reader] == 8) { //backspace char or delete char
			if(writer > 0) //taken into account so the writer isn't being subtracted to a negative index
				writer--;
		}
		else {
			convertedInput[writer] = inp[reader]; //store char from reader into writer
			writer++;
		}
		reader++; //always incrementing writer
	}
	convertedInput[writer] = '\0'; //add null terminator


	/**********************************FIND NUMBER OF WORDS**********************************/
	for(int i = 0; convertedInput[i] != '\0'; i++) { //Iterate until end of the input string
		if(convertedInput[i] != ' ') {
			currentWordLength++;

			//Found a valid character
			if(convertedInput[i+1] == '\0') { //If the next char is the end of the file
				//This gets around the edge case of the for loop stopping when it reaches '\0'
				if(currentWordLength > 0)
					numberOfWords++;
				currentWordLength = 0; //Reset
				continue;
			}

		}
		else {
			//Invalid Character
			if(convertedInput[i-1] == ' ' || convertedInput[i-1] == 127 || convertedInput[i-1] == 8)
				continue;
			else {
				//word is finished
				if(currentWordLength > 0)
					numberOfWords++;
				currentWordLength = 0;
			}
		}
	}

	//allocate single char pointers for number of words
	(*array_of_words_p) = (char**)malloc(sizeof(char*) * (size_t)numberOfWords);


	/**********************************FIND NUMBER OF WORDS**********************************/
	//Reset variables
	currentWordLength = 0;
	int wordIndex = 0; //Used in array indexes
	for(int i = 0; convertedInput[i] != '\0'; i++) {
		if(convertedInput[i] != ' ') { 	//not a space - valid character
			currentWordLength++;

			if(convertedInput[i+1] == '\0' && currentWordLength > 0) {
				//next character is the end, it would not pick up the end of the word
				(*array_of_words_p)[wordIndex] = (char*)malloc(sizeof(char) * (size_t)(currentWordLength + 1)); //Plus 1 is for null terminator
				currentWordLength = 0;
			}
		}
		else {
			//Invalid Character
			if(convertedInput[i-1] == ' ' || convertedInput[i-1] == 127 || convertedInput[i-1] == 8)
				continue;
			else {
				//End of word
				(*array_of_words_p)[wordIndex] = (char*)malloc(sizeof(char) * (size_t)(currentWordLength)+1); //Plus 1 is for null terminator
				wordIndex++;
				currentWordLength = 0;
			}
		}
	}

	/**********************************FIND NUMBER OF LETTERS IN EACH WORD**********************************/
	currentWordLength = 0;
	wordIndex = 0;
	int letterIndex = 0;

	for(int i = 0; convertedInput[i] != '\0'; i++) {
		if(convertedInput[i] != ' ') {
			//valid character
			(*array_of_words_p)[wordIndex][letterIndex] = convertedInput[i];

			letterIndex++;
			if(convertedInput[i+1] == '\0') { //End of string
				(*array_of_words_p)[wordIndex][letterIndex] = '\0';
				wordIndex++;
				letterIndex = 0;
			}
		}
		else {
			//Invalid Character
			if(convertedInput[i-1] == ' ' || convertedInput[i-1] == 127 || convertedInput[i-1] == 8)
				continue;
			else
			{
				//reached end of word
				(*array_of_words_p)[wordIndex][letterIndex] = '\0';
				wordIndex++;
				letterIndex = 0;
			}
		}
	}

	//free the converted input as we do not need it anymore
	free(convertedInput);

	return numberOfWords;
}





Button buildButton(int x , int y, int w, int h, int id){

	Button b;
	b.startX = x;
	b.startY = y;
	b.width = w;
	b.height = h;
	b.id = id;

	b.text = textArray[id];

	return b;
}




void analyseTouch(Button currentButtonPressed)
{
	printf("Hello and welcome to analyseTouch\n");
	printf("Current button text is %s, button id is %d\n", currentButtonPressed.text, currentButtonPressed.id);

	//https://stackoverflow.com/a/6161123
	if(firstTime == 1)
	{
		inputString = (char*)malloc(sizeof(char) * maxSize);
		strcpy(inputString, "0");  //init


		//printf("input string starts with %s", inputString);
		firstTime = 0;
	}

    if(equalsPressed == 1)
    {
		equalsPressed = 0;
		strcpy(inputString,""); //reset input string
//		BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
//		BSP_LCD_FillRect(1, 1, 318, 78);
//		//revert to black text
//		BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
    }

	int buttonId = currentButtonPressed.id;

	printf("Button id is: %d\n", buttonId);

	char* buttonText = currentButtonPressed.text;
	printf("Button to text is %s\n\n", buttonText);
//
//	printf("sizeof inputstring %d\n", sizeof(inputString));
//	printf("strlen inputString %d\n\n", strlen(inputString));

	if(strlen(inputString) == 1 && inputString[0] == '0') //Length 1 and only "0"
	{
		//blank string
		printf("Recognised strlen of 1 and only a 0\n");

		if(strcmp(buttonText,"0") == 0)
		{
			printf("0 was entered. Nothing to achieve on blank string\n");
			//return;
		}
		if(strcmp(buttonText, "=") == 0)
		{
			printf("= was entered. Nothing to achieve on blank string\n");
			//return;
		}
		if(strcmp(buttonText, "clr") == 0)
		{
			printf("clr was entered. Nothing to achieve on blank string\n");
			//return;
		}
		if(strcmp(buttonText, "1") == 0 ||strcmp(buttonText, "2") == 0 || strcmp(buttonText, "3") == 0 ||
				strcmp(buttonText, "4") == 0 ||strcmp(buttonText, "5") == 0 || strcmp(buttonText, "6") == 0 ||
				strcmp(buttonText, "7") == 0 || strcmp(buttonText, "8") == 0 || strcmp(buttonText, "9") == 0)
		{
			//replace current "0" with another number
			printf("found %s. replacing current 0\n", buttonText);
			strcpy(inputString, buttonText);
		}

		if(strcmp(buttonText, ".") == 0)
		{
			concatenateButtonText(buttonText);
			decimalPointPlaced = 1;


		}
		if(strcmp(buttonText, "+") == 0 || strcmp(buttonText, "-") == 0 ||
				strcmp(buttonText, "/") == 0 || strcmp(buttonText, "*") == 0)
		{
			concatenateButtonText(buttonText);
		}
		if(strcmp(buttonText, "+-") == 0){
			printf("found %s. replacing current 0\n", "-");
			strcpy(inputString, "-");



		}

	}
	else if(strcmp(buttonText, "0") == 0 || strcmp(buttonText, "1") == 0 || strcmp(buttonText, "2") == 0 ||
			strcmp(buttonText, "3") == 0 || strcmp(buttonText, "4") == 0 || strcmp(buttonText, "5") == 0 ||
			strcmp(buttonText, "6") == 0 || strcmp(buttonText, "7") == 0 || strcmp(buttonText, "8") == 0 ||
			strcmp(buttonText, "9") == 0)
	{
		//append to end of string
		concatenateButtonText(buttonText);
	}
	else if(strcmp(buttonText, ".") == 0)
	{
		//make sure there isnt a decimal point already placed
		if(decimalPointPlaced == 0)
		{
			//go for it
			concatenateButtonText(buttonText);
			decimalPointPlaced = 1;
		}
		else
		{
			printf("error. already placed decimal point...\n");
			//return;
		}
	}
	else if(strcmp(buttonText, "+") == 0 || strcmp(buttonText, "-") == 0 ||
			strcmp(buttonText, "/") == 0 || strcmp(buttonText, "*") == 0)
	{
		printf("found +,-,/,*\n");

		char previousChar = inputString[inputStringIndex];
		printf("comparing char=> %c",previousChar);
		//check that operator is not placed twice in a row
		if((previousChar == '+' && strcmp(buttonText, "+") == 0) ||
				(previousChar == '-' && strcmp(buttonText, "-") == 0) ||
				(previousChar == '/' && strcmp(buttonText, "/") == 0) ||
				(previousChar == '*' && strcmp(buttonText, "*") == 0))
		{
			//error cant do that mate
			printf("Error. cannot have 2 operators in a row\n");
			return;
		}
		//if previous char is operator and new char is operator
		//replace old operator with new operator
		else if((previousChar == '-' || previousChar == '/' || previousChar == '*') && strcmp(buttonText,"+") == 0)
		{
			inputString[inputStringIndex] = '+';
			decimalPointPlaced = 0;

		}
		else if((previousChar == '+' || previousChar == '/' || previousChar == '*') && strcmp(buttonText,"-") == 0)
		{
			inputString[inputStringIndex] = '-';
			decimalPointPlaced = 0;

		}
		else if((previousChar == '+' || previousChar == '-' || previousChar == '*') && strcmp(buttonText,"/") == 0)
		{
			inputString[inputStringIndex] = '/';
			decimalPointPlaced = 0;

		}
		else if((previousChar == '+' || previousChar == '-' || previousChar == '/') && strcmp(buttonText,"*") == 0)
		{
			inputString[inputStringIndex] = '*';
			decimalPointPlaced = 0;

		}
		//todo missing functionality for pow, mod sqrt etc.
		else //add like normal
		{
			//last char was not an operator
			//append new operator to string
			//go for it mate
			concatenateButtonText(buttonText);
			decimalPointPlaced = 0;

		}
	}
	else if(strcmp(buttonText, "=") == 0)
	{
		//cannot parse string if there is an operator at the end of string
		char lastChar = inputString[inputStringIndex];
		if(lastChar == '+' || lastChar ==  '-' || lastChar ==  '/' ||  lastChar == '*')
		{
			printf("Error. last character is an operator. cannot do equals yet\n");
		}
		else
		{
			double result = doEquals2();
//			double result = doEquals(); //todo get iplementation for double to string for output
//			result ++; //todo not relevant, must be removed before submission
//			strcpy(inputString,"0");
			char resultString [64];
			snprintf(resultString, sizeof(resultString), "%f",result);
			strcpy(inputString, resultString);
			//reset variables

			firstTime = 1;
			inputStringIndex = 0;
			decimalPointPlaced = 0;
//			BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
//			BSP_LCD_FillRect(1, 1, 318, 78);
//			BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
			equalsPressed = 1;
//	      	BSP_LCD_DisplayStringAt(20,40,resultString ,LEFT_MODE);

		}
	}
	else if(strcmp(buttonText, "clr") == 0)
	{
		printf("in clr with non empty string\n");
		//reset variables
		strcpy(inputString,"0");
		//free(inputString);
		firstTime = 1;
		inputStringIndex = 0;
		decimalPointPlaced = 0;
		//make white rectangle
//		BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
//		BSP_LCD_FillRect(1, 1, 318, 78);
//		//revert to black text
//		BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

	}
	else if(strcmp(buttonText , "+-") == 0)
	{
		if(inputString[inputStringIndex] == '-' && (inputStringIndex ==0  || isOperator(inputString[inputStringIndex-1]))){
			//the minus we are looking at is for negating a number\
			//so we need to remove it
			inputString[inputStringIndex] = '\0';
			inputStringIndex -=1;


		}else if(inputStringIndex !=0 && !isOperator(inputString[inputStringIndex])){
			//the minus needs to be before a number, therefore it needs to be after an operator(or at the start of the string)
			//so error
			printf("inputStringIndex %d\n", inputStringIndex);
			printf("Error. negative sign needs to be placed before a number\n");
			return;

		}else{//in every other case we good

			concatenateButtonText("-");


		}

	}
	else
	{
		printf("Hey you pressed a button that doesnt have implementation yet\n");
	}

	printf("Current String=> %s\n", inputString);
}

void concatenateButtonText(char* buttonText)
{


	if(inputStringIndex + 3 >= maxSize){
		maxSize *= 2;
		inputString = (char*)realloc(inputString, maxSize*sizeof(char));
	}
//	inputString = realloc(inputString, (inputStringIndex + 2) * sizeof(char));
	strcat(inputString, buttonText);
	inputStringIndex += strlen(buttonText);
	printf("inputstringindex => %d\n", inputStringIndex);

}
double doEquals2(){

	printf("Entering doEquals2()   inputString %s\n", inputString);

	int numberOfNumbers = 0;
	int numberOfOperators = 0;
	int lookingAtNumber = 0;
	for(int i = 0; i< (int)strlen(inputString); i++){
		if(isOperator(inputString[i])){
			numberOfOperators +=1;
			lookingAtNumber =0;
		}else{
			if(lookingAtNumber == 0){
				numberOfNumbers +=1;
				lookingAtNumber = 1;
			}
		}
	}



	char** numbers = (char**)malloc(sizeof(char*) * numberOfNumbers);
	char* operators = (char*)malloc(sizeof(char) * numberOfOperators);
	int numbersIndex = 0;
	int operatorIndex = 0;
	int startI = 0;
	for(int i = 0 ;i< (int)strlen(inputString); i++){
		if(isOperator(inputString[i])){
			if(startI <= i-1){
				char* tempNumber = (char*)malloc(sizeof(char) *( i-startI+1));
				strncpy(tempNumber, &inputString[startI],i-startI);
				tempNumber[i-startI] ='\0';
//				double d;
//				sscanf(tempNumber,"%lf",&d);
				numbers[numbersIndex] = tempNumber;
				numbersIndex +=1;

//				free(tempNumber);
				startI = i+1;

				operators[operatorIndex] = inputString[i];
				operatorIndex +=1;

			}else{//if previous index was an operator as well or this is the first position then this is a minus
			}



		}
	}

	//add the last number
	int i = (int)strlen(inputString);
	char* tempNumber = (char*)malloc(sizeof(char) *( i-startI+1));
	strncpy(tempNumber, &inputString[startI],i-startI);
	tempNumber[i-startI] ='\0';
//	double d;
//	sscanf(tempNumber,"%lf",&d);
	numbers[numbersIndex] = tempNumber;
	numbersIndex +=1;

//	free(tempNumber);


	//print stuff
	printf("numberOfNumbers %d  numberOfOperators %d\n",numberOfNumbers, numberOfOperators);
	for(int i = 0 ; i< numberOfNumbers;i++){
		printf("numbers %d : %s\n", i,numbers[i]);

	}

	for(int i = 0 ; i< numberOfOperators;i++){
		printf("operators %d : %c\n", i,operators[i]);

	}



	char operatorOrder[2][2]= {{'*', '/'},{'+', '-'}};

	for(int operatorGroup = 0; operatorGroup < 2; operatorGroup++){//for each operator grouping
		for(int i = 0; i< numberOfOperators;i++){//for each operator in operator list from input string
			for(int specificOperator = 0; specificOperator < 2; specificOperator++ ){//for each operator in the group
				if(operators[i] == operatorOrder[operatorGroup][specificOperator]){
					//if operator found which matches the one we are looking at
					float result = 0;
					char resultString[64];
					result = compute(operators[i],numbers[i], numbers[i+1]);
					snprintf(resultString, sizeof(resultString), "%f",result);
					printf("left Number: %s \t operator: %c \t right Number: %s \t result: %s \n", numbers[i], operators[i], numbers[i+1], resultString);


					//now we need to repopulate the numbers and operators array
					for(int j = 0; j< numberOfNumbers-1;j++){
						if(j<i){//just copy it across
//							strcpy(newNumbers[j], numbers[j]);

						}else if(j==i){
							free(numbers[j]);
							strcpy(numbers[j], resultString);
	//							newNumbers[j] = resultString;

						}else{
							free(numbers[j]);
							strcpy(numbers[j], numbers[j+1]);

//							newNumbers[j] = numbers[j+1];
						}
					}
					numberOfNumbers-=1;
//					numbers = (char**)realloc(sizeof(char*) * numberOfNumbers);
					for(int j = 0; j< numberOfOperators-1;j++){
						if(j<i){//just copy it across
//							strcpy(newNumbers[j], numbers[j]);

						}else if(j>=i){
							operators[j] = operators[j+1];

//							newNumbers[j] = numbers[j+1];
						}
					}

					numberOfOperators -=1;
//					operators = (char*)realloc(sizeof(char) * numberOfOperators);




//
//					char** newNumbers = (char**)malloc(sizeof(char*) * numberOfNumbers-1);
//					char* newOperators = (char*)malloc(sizeof(char) * numberOfOperators-1);
//
//
//					for(int j = 0; j< numberOfNumbers-1;j++){
//						if(j<i){//just copy it across
//							strcpy(newNumbers[j], numbers[j]);
//
//						}else if(j==i){
//							strcpy(newNumbers[j], resultString);
////							newNumbers[j] = resultString;
//
//						}else{
//							newNumbers[j] = numbers[j+1];
//						}
//					}
//
//					numbers = newNumbers;

					if(numberOfOperators ==0){
						double finalResult =0;
						sscanf(numbers[0],"%lf",&finalResult);
						printf("finalResult %lf\n", finalResult );
						return finalResult;
					}


					i--;
					break;


				}
			}
		}
	}


	double finalResult =0;



	sscanf(numbers[0],"%lf",&finalResult);
	return finalResult;



}


double doEquals()
{
	int done = 0;
	int stringIsAllNumbers = 1;
	int memorySize = 20;
	char* newString;
	newString = malloc(sizeof(char) * 1);
	strcpy(newString, "");  //init
	float result = 0;
	printf("Parsing is kinda implemented\n");

	char operators[2][2]= {{'*', '/'},{'+', '-'}};
	char resultString[64];
//	while(done == 0)
//	{
//		printf("looping...\n");
		for(int i = 0 ; i < 2; i++)
		{
			//for(int j = 0 ; j<inputStringIndex + 1 ; j++ )
			for(int j = 0; j <= (int)strlen(inputString);j++)
			{
				for(int k = 0 ; k< 2;k++)
				{
					if(operators[i][k] == inputString[j])
					{
	//					printf("input string at 1 %s\n", inputString);

						printf("found operator %c\n" , inputString[j]);
						int leftCounter = 1;
						while(j-leftCounter >= 0 && !isOperator(inputString[j-leftCounter]))
						{
							leftCounter+=1;
						}
						if(leftCounter == 1){
							for(int z = j+1; z < (int)strlen(inputString); z++){
								if(isOperator(inputString[z])){
									j = z;
									int leftCounter = 1;
									while(j-leftCounter >= 0 && !isOperator(inputString[j-leftCounter]))
									{
										leftCounter+=1;
									}
									break;


								}

							}

						}
						if(leftCounter ==1){
							return result;

						}

						int rightCounter = 1;

	//					while(j+rightCounter < inputStringIndex + 1 && !isOperator(inputString[j+rightCounter]))
						while(j+rightCounter < (int)strlen(inputString) && !(isOperator(inputString[j+rightCounter]) && rightCounter != 1))
						{
							rightCounter+=1;
						}




	//					printf("input string at 3 %s", inputString);

						printf("Left %d, Right %d, j %d\n", leftCounter, rightCounter , j);


	//					printf("inputString before %s\n", inputString);



						char* leftNum = (char*)malloc(sizeof(char) * (leftCounter-1));
						printf("1");
						strcpy(leftNum, "");  //init
						printf("1");
						strncat(leftNum, &inputString[j-leftCounter+1], leftCounter -1);
						printf("1");
						char* rightNum = (char*)malloc(sizeof(char) * (rightCounter-1));
						printf("1");
						strcpy(rightNum, "");  //init
						printf("1");
						strncat(rightNum, &inputString[j +1], rightCounter -1);

						printf("inputString %s\n", inputString);
						printf("rightNum %s\n", rightNum);
						printf("leftNum %s\n\n", leftNum);

						result = compute(operators[i][k],leftNum,rightNum);
						snprintf(resultString, sizeof(resultString), "%f",result);

						char* fixedString = (char*)malloc(sizeof(char));
						strcpy(fixedString, "");
						int fixedStringIndex = 0;

						for(int z = 0; z <= j-leftCounter;z++)
						{
							fixedString[fixedStringIndex] = inputString[z];
							fixedStringIndex++;
							if(fixedStringIndex == memorySize)
							{
								memorySize *= 2;
								fixedString = (char*)realloc(fixedString,sizeof(char) * memorySize);

							}
						}
						snprintf(resultString, sizeof(resultString), "%f", result);

						for(int z = 0; resultString[z] != '\0';z++)
						{
							fixedString[fixedStringIndex] = resultString[z];
							fixedStringIndex++;
							if(fixedStringIndex == memorySize)
							{
								memorySize *= 2;
								fixedString = (char*)realloc(fixedString,sizeof(char) * memorySize);

							}
						}

						for(int z = j + rightCounter; z < (int)strlen(inputString);z++)
						{
							fixedString[fixedStringIndex] = inputString[z];
							fixedStringIndex++;
							if(fixedStringIndex == memorySize)
							{
								memorySize *= 2;
								fixedString = (char*)realloc(fixedString,sizeof(char) * memorySize);

							}
						}
						if(fixedStringIndex +1 == memorySize){
							fixedString = (char*)realloc(fixedString,sizeof(char)*(memorySize +1));
						}

						fixedString[fixedStringIndex] = '\0';
						fixedStringIndex++;

						printf("Current fixed stirng %s\n", fixedString);
						//string is now fixed
						free(inputString);
						inputString = (char*)malloc(sizeof(char) *(int)strlen(fixedString));

						strcpy(inputString, fixedString);
						free(fixedString);
						free(leftNum);
						free(rightNum);


						int foundOperator = 0;
						for(int z = 0; z < (int)strlen(inputString);z++)
						{
							printf("Current char in inputstring =>%c\n", inputString[z]);
							if(isOperator(inputString[z]) == 1)
							{
								foundOperator = 1; //not done
								break;
							}
						}
						if(foundOperator == 0)//no more operators
						{
							done = 1; //finished
						}
					}
					else
					{
						//printf("found number");
						//need to check if there are any operators in the string
						for(int z = j; z <= (int)strlen(inputString);z++)
						{
							//printf("Current char in inputstring =>%c\n", inputString[z]);
							stringIsAllNumbers = stringIsAllNumbers && (isOperator(inputString[z]) == 0);
						}
						if(stringIsAllNumbers == 1)
						{
							printf("string was all numbers\n");
							done = 1;
							return atof(inputString);

						}
					}
				}
			}
		}
//	}


	printf("Final result is %s", resultString);


	return result;
}


float compute(char operator,char* leftNum,char* rightNum){
	/**
	*	Used as reference to commandList[]
	*
	*   {"add",  &validateAddition, "add <num 1> .. <num N>\n"},
	*	{"sub",  &validateSubtraction, "sub <num 1> <num 2>\n"},
	*	{"mul",  &validateMultiplication, "mul <num 1> .. <num N>\n"},
	*	{"div",  &validateDivision, "div <num 1> <num 2>\n"},
	*	{"sqrt", &validateSquareRoot, "sqrt <num1> : Finds the square root of a floating point number.\n"},
	*	{"cbrt", &validateCubeRoot,"cbrt <num1> : Finds the cube root of a floating point number.\n"},
	*	{"pow",  &validatePower,"pow <num1> <num2> : Finds the power of the num1 to the power of num2.\n"},
	*	{"mod",  &validateModulo,"mod <num1> <num2>: Finds the modulo of two INTEGERS.\n"},
	*	{"debug",&debugMode,"debug <on|off> : Turn debug messages on or off.\n"},
	*	{"help", &helpDesk,"help [command] : Prints help information for a command\n"},
	*	{NULL, NULL, NULL}
	**/




	//todo use correct names for function
	float result = 0;
	char* numbers[3] = {NULL,leftNum,rightNum};
	switch(operator){
	case '*':
		numbers[0] = commandList[2].nameString;
		result = commandList[2].function_p(3,numbers);
		//result = mulNumbers(3,numbers);//mul [left] [right].
		break;
	case '/':
		numbers[0] = commandList[3].nameString;
		result = commandList[3].function_p(3,numbers);
		//result = divNumbers(3,numbers);
		break;
	case '+':
		numbers[0] = commandList[0].nameString; //printf("about to add\n");
		result = commandList[0].function_p(3,numbers);
		//printf("finished add\n");

//		result = atof(leftNum);
//		printf("leftNum %f\n",atof(leftNum));
//		printf("result -> %f\n", result);
//
//		result += atof(rightNum);
//		printf("result -> %f\n", result);
////		result = addNumbers(2,numbers);
		break;
	case '-':
		numbers[0] = commandList[1].nameString;
		result = commandList[1].function_p(3,numbers);
		//result = subNumbers(2,numbers);
		break;
	}


	return result;


}


int isOperator(char input ){
	if(input == '*' || input == '/' || input == '+' || input == '-'){
		return 1;
	}
	return 0;
}
