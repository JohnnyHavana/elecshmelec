/**
 * ELEC3730 ASSIGNMENT 2
 * QUESTION 1 - COMMAND LINE PARSER
 * JORDAN HAIGH AND EVAN GRESHAM
 *
 * File takes in user input either from STM32 (Putty) or command line
 * Utilises keywords to perform mathematical functions
 * */

#include "Ass-02.h"
#include "Ass-02-Q01.h"
#include <math.h>
#include <stdlib.h>


#ifdef STM32F407xx
#include "usart.h"
#endif

//Global constants necessary for consistent looping
uint8_t debugOn = 0;
int wordCount = 0;
char **array_of_words; //array of words found from command line
char* newString; //building string from command line
int length = 10; //used for memory allocation
int stringIndex = 0;
uint8_t buildInputStringFirstTime = 1;



//Structure defined inside C file, though defined in the .h file
//Allows for structure to be used in Question 2
#ifndef MECOMMANDLIST
#define MECOMMANDLIST
const command_s commandList[] = {
		{"add",  &validateAddition, "add <num 1> .. <num N>\n"},
		{"sub",  &validateSubtraction, "sub <num 1> <num 2>\n"},
		{"mul",  &validateMultiplication, "mul <num 1> .. <num N>\n"},
		{"div",  &validateDivision, "div <num 1> <num 2>\n"},
//		{"sqrt", &validateSquareRoot, "sqrt <num1> : Finds the square root of a floating point number.\n"},
//		{"cbrt", &validateCubeRoot,"cbrt <num1> : Finds the cube root of a floating point number.\n"},
//		{"pow",  &validatePower,"pow <num1> <num2> : Finds the power of the num1 to the power of num2.\n"},
//		{"mod",  &validateModulo,"mod <num1> <num2>: Finds the modulo of two INTEGERS.\n"},
//		{"debug",&debugMode,"debug <on|off> : Turn debug messages on or off.\n"},
//		{"help", &helpDesk,"help [command] : Prints help information for a command\n"},
		{NULL, NULL, NULL}

};
#endif

/*
 * If the program has found more than 1 word, print out each word found
 * */
void printArrayOfWords()
{
	if (wordCount != 0) {
		printf("count = %d\n", wordCount);
		for (int j=0;j<wordCount;j++) {
		  printf("Word(%d): '%s'\n", j+1, (array_of_words)[j]);
		}
	  }
	else
		printf("No words found\n");
}

/*
 * Used to free global char arrays - newString(created from newString), array_of_words
 * */
void freeEverything()
{
	free(newString);
	free(array_of_words);
}


/*
 * Main area where the keywords found from command line are parsed
 * Gathers the first keyword and checks char by char if it is a valid keyword for mathematical operation
 * Needs to check first if the string parser was able to find any words - otherwise crash.
 * */
void analyseKeywords(uint8_t argNum, char* argStrings[])
{

	if(argNum == 0)
	{
		printf("Error. No input. Seek help.\n");
		return;
	}

	char* firstKeyword  = (argStrings)[0];

	//must be either add,sub,mul,div
	if(firstKeyword[0] == 'a' && firstKeyword[1] == 'd' && firstKeyword[2] == 'd' && firstKeyword[3] == '\0')
		validateAddition(argNum, argStrings);
	else if(firstKeyword[0] == 's' && firstKeyword[1] == 'u' && firstKeyword[2] == 'b' && firstKeyword[3] == '\0')
		validateSubtraction(argNum, argStrings);
	else if(firstKeyword[0] == 'm' && firstKeyword[1] == 'u' && firstKeyword[2] == 'l' && firstKeyword[3] == '\0')
		validateMultiplication(argNum, argStrings);
	else if(firstKeyword[0] == 'd' && firstKeyword[1] == 'i' && firstKeyword[2] == 'v' && firstKeyword[3] == '\0')
		validateDivision(argNum, argStrings);
	else if(firstKeyword[0] == 'h' && firstKeyword[1] == 'e' && firstKeyword[2] == 'l' && firstKeyword[3] == 'p' && firstKeyword[4] == '\0')
			helpDesk(argNum,argStrings);
	else if(firstKeyword[0] == 'd' && firstKeyword[1] == 'e' && firstKeyword[2] == 'b' && firstKeyword[3] == 'u' && firstKeyword[4] == 'g' && firstKeyword[5] == '\0')
		debugMode(argNum,argStrings);



	//EXTRA FUNCTIONALITY
	else if(firstKeyword[0] == 's' && firstKeyword[1] == 'q' && firstKeyword[2] == 'r' && firstKeyword[3] == 't' && firstKeyword[4] == '\0')
		validateAndRunRoot(0, argNum, argStrings);
	else if(firstKeyword[0] == 'c' && firstKeyword[1] == 'b' && firstKeyword[2] == 'r' && firstKeyword[3] == 't' && firstKeyword[4] == '\0')
		validateAndRunRoot(1,argNum, argStrings);
	else if(firstKeyword[0] == 'p' && firstKeyword[1] == 'o' && firstKeyword[2] == 'w' && firstKeyword[3] == '\0')
		validatePower(argNum, argStrings);
	else if(firstKeyword[0] == 'm' && firstKeyword[1] == 'o' && firstKeyword[2] == 'd' && firstKeyword[3] == '\0')
		validateModulo(argNum, argStrings);


	else
		printf("Error. Unrecognised command. Seek help.\n");

}
/*
 * Performs error checking on the argStrings to make sure its valid input before calculating the square root
 * */
double validateSquareRoot(uint8_t argNum, char* argStrings[])
{
	return validateAndRunRoot(0,argNum,argStrings);
}

/*
 * Performs error checking on the argStrings to make sure its valid input before calculating cube root
 * */
double validateCubeRoot(uint8_t argNum, char* argStrings[])
{
	return validateAndRunRoot(1,argNum,argStrings);
}

/*
 * Checks that the argument length of string is correct. If correct,
 * */
double validateAndRunRoot(uint8_t flag, uint8_t argNum, char* argStrings[])
{
	double result = 0; //Start at zero. Will be changed later
	if(checkArgumentLength2(1,2, argNum) == 0) //If Fail
		printf("Error. Must contain only one number for Root.\n");
	else
	{
		//Argument length did not fail, make sure we are working with numerical arguments
		if(checkForNumericArgument2(0,argNum, argStrings) == 1)
		{
			//double result;
			if(flag == 0) //Flag for calculating square root
				result = squareRoot(argStrings);
			else //Flag for calculating cube root
				result = cubeRoot(argStrings);

			printf("Result: %lg\n", result); //Print result to putty/command line
		}
	}

	return result;
}

/*
 * Calculate the square root of the second inputted argument
 * */
double squareRoot(char* argStrings[])
{
	double result = strtof(argStrings[1],NULL);
	return sqrtf(result);
}
/*
 * Calculate the cube root of the second inputted argument
 * */
double cubeRoot(char* argStrings[])
{
	return cbrtf(strtof(argStrings[1],NULL));
}

/*
 * Validate the arguments of the string to make sure they can be used for calculating the power
 * If all arguments are valid and or numerals, we can calculate the power of the number
 * Bonus easter egg if three arguments are entered
 * */
double validatePower(uint8_t argNum, char* argStrings[])
{
	double result = 0;
 	if(checkArgumentLength2(1,3, argNum) == 0)
	{
			printf("Error. Must contain only two numbers for Powers. ");
			(argNum > 3) ? printf("No one man should have all that power.\n") : printf("\n");
	}
	else
	{
		if(checkForNumericArgument2(0,argNum, argStrings) == 1)
		{

			result = power(argStrings);
			printf("Result: %lg\n", result);
		}
	}
 	return result;
}
/*
 * Calculate the first argument to the power of the second argument
 * */
double power(char* argStrings[])
{
	return powf(strtof(argStrings[1],NULL),strtof(argStrings[2],NULL));
}

/*
 * Validate the arguments of the string to make sure they can be used for calculating the modulo
 * If all arguments are valid and or numerals, we can calculate the modulo of the two numbers
 * Only accepted two INTEGERS as arguments
 */
double validateModulo(uint8_t argNum, char* argStrings[])
{
	double result = 0;
	if(checkArgumentLength2(1,3,argNum) == 0)
		printf("Error. Must contain only two integers for Modulo.\n");
	else
	{
		if(checkForNumericArgument2(1,argNum,argStrings) == 1)
		{
			result = modulo(argStrings);
			printf("Result: %lg\n", result);
		}
	}
	return result;
}

/*
 * Calculate and return the modulo of the first number mod second number
 * */
int modulo(char* argStrings[])
{
	return (int)strtof(argStrings[1],NULL) % (int)strtof(argStrings[2],NULL);
}

/*
 * Validity check used by mathematical functions. Depending on the flag and expected word count, it will
 * return 1 for true and 0 for false.
 * Add and mul can accept any number of arguments
 * Sub, div, and other functions require two arguments
 * */
uint8_t checkArgumentLength2(uint8_t flag, uint8_t expectedWordCount, uint8_t argNum)
{
	if(argNum == 1)
		return 0;

	if(flag == 0) //used for addition and subtraction. N number of arguments supported
		return 1;
	else //flag must be 1. flag is used in the operations where a number of arguments is specified, i.e sub, div, sqrt, sbrt, mod, pow
	{
		if(argNum < expectedWordCount || argNum > expectedWordCount)
			return 0;
		else
			return 1;

	}
}


/*
 * Validity check used by mathematical functions. It will return true or false depending whether the argument is all
 * numerals or not. Also takes into account the positioning of the decimal point (decimal point cant be placed twice for same number)
 * */
uint8_t checkForNumericArgument2(uint8_t processingIntegerFlag,uint8_t argNum, char* argStrings[])
{
	uint8_t foundDecimalPoint = 0;

	for(int i = 1; i < argNum; i++)
	{

		for(int j = 0; argStrings[i][j] != '\0'; j++) //check each letter in the word
		{
			if(argStrings[i][j] == '.')
			{ //searching for decimal point

				if(foundDecimalPoint == 0)
					foundDecimalPoint = 1;
				else
				{
					printf("Error. Not a valid input\n");
					return 0;
				}
			}

			else if(!(argStrings[i][j] >= 48 && argStrings[i][j] <= 57) && !argStrings[i][j] == '-')
			{
				//if the number is not within 0-9 (non numeric)

				printf("Error. Not a valid input\n");
				return 0;
			}

			else if(processingIntegerFlag == 1 && foundDecimalPoint == 1 && (argStrings[i][j] >= 48 && argStrings[i][j] <= 57)) //if a decimal point is found and numerals trail it, it must be a decimal
			{
				printf("Error. Not a valid Input\n");
				return 0;
			}

		}
		//new word, reset decimal point
		foundDecimalPoint = 0;
	}

	return 1;
}

/*
 * Validity check used before actually completing addition. Number of arguments must be greater than or equal to 1
 * Needs to check that the arguments are numeric as well before adding numbers
 * */
double validateAddition(uint8_t argNum, char* argStrings[])
{
	double result = 0;
	if(checkArgumentLength2(0,99, argNum) == 0)
		printf("Error. Must contain one or more numbers for addition.\n");
	else
	{
		if(checkForNumericArgument2(0,argNum,argStrings) == 1)
		{
			result = addNumbers(argNum, argStrings);
			printf("Result: %lg\n", result);
		}
	}
	return result;
}

/*
 * Adds numbers together and returns as a double
 * */
double addNumbers(uint8_t argNum, char* argStrings[])
{

	double currentSum = 0;

	for(int i = 1; i < argNum; i++)
	{
		double stringToDouble = strtof(argStrings[i],NULL);
		currentSum += stringToDouble;
	}

	return currentSum;
}

/*
 * 	Validity check before subtracting arguments. Number of arguments must only be 2.
 * 	Needs to check that all arguments are numeric before subtracting
 * */
double validateSubtraction(uint8_t argNum, char* argStrings[])
{
	double result = 0;
	if(checkArgumentLength2(1,3,argNum) == 0)
		printf("Error. Must contain exactly two numbers for subtraction\n");
	else
	{
		if(checkForNumericArgument2(0,argNum, argStrings) == 1)
		{
			result = subNumbers(argNum, argStrings);
			printf("Result: %lg\n", result);
		}
	}
	return result;
}

/*
 * 	Subtract second argument from first argument
 * 	Flag used to determine first argument
 * */
double subNumbers(uint8_t argNum, char* argStrings[])
{
	double currentSub = 0;
	uint8_t firstRun = 1;
	for(int i = 1; i < argNum; i++)
	{
		double stringToDouble = strtof(argStrings[i],NULL);

		if(firstRun == 1)
		{
			currentSub = stringToDouble;
			firstRun = 0;
		}
		else
			currentSub -= stringToDouble;
	}

	return currentSub;

}

/*
 * 	Validity check before calculating multiplication. Argument length can be infinite
 * 	Must check that arguments are numerical before starting multiplication.
 * 	Once valid, we can compute multiplication
 * */
double validateMultiplication(uint8_t argNum, char* argStrings[])
{
	double result = 0;
	if(checkArgumentLength2(0,99,argNum) == 0)
		printf("Error. Must contain one or more numbers for multiplication.\n");
	else
	{
		if(checkForNumericArgument2(0,argNum,argStrings) == 1)
		{
			result = mulNumbers(argNum, argStrings);
			printf("Result: %lg\n", result);
		}

	}
	return result;
}

/*
 * Multiply N numbers together.
 * Uses a flag to start the first argument as the current multiple.
 * That way it isnt always going to be returning 0;
 * */
double mulNumbers(uint8_t argNum, char* argStrings[])
{
	double currentMul = 0;
	uint8_t firstTime = 1;
	for(int i = 1; i < argNum; i++)
	{
		double stringToDouble = 0;
		sscanf(argStrings[i],"%lg",&stringToDouble);
		//printf("In mul - number to mul is %lg\n", stringToDouble);


		//double stringToDouble = strtof((argStrings)[i]);

		if(firstTime)
		{
			currentMul = stringToDouble;
			firstTime = 0;

		}
		else
			currentMul *= stringToDouble;
	}
	//printf("Current myl is %lg\n", currentMul);

	return currentMul;
}

/*
 * Validity check before calculating the division of two numbers. Must be only two arguments
 * Validity check of numerals conducted before division can start
 * */
double validateDivision(uint8_t argNum, char* argStrings[])
{
	double result = 0;
	if(checkArgumentLength2(1,3,argNum) == 0)
		printf("Error. Must contain exactly two numbers for division\n");
	else
	{
		if(checkForNumericArgument2(0,argNum,argStrings) == 1)
		{
			result = divNumbers(argNum,argStrings);
			printf("Result: %lg\n", result);
		}
	}
	return result;
}

/*
 * Divide number 1 by number 2
 * Uses flag to allocate first number as current divider
 * If any of the inputs is a zero, straight away returns zero. (Always going to be zero and gets around DivideByZeroException)
 * */
double divNumbers(uint8_t argNum, char* argStrings[])
{
	double currentDiv = 0;
	uint8_t firstRun = 1;
	if(strcmp(argStrings[2],"0") == 0){
		printf("Error cannot divide by 0\n");
		return 0;

	}
	for(int i = 1; i < argNum; i++)
	{
		double stringToDouble = strtof((argStrings)[i],NULL);
		if(stringToDouble == 0.0)
		{

			return 0.0; //it was always going to be a 0.0 result regardless - smart boy
			//gets around the divide by zero exception
		}

		if(firstRun == 1)
		{
			currentDiv = stringToDouble;
			firstRun = 0;
		}
		else
			currentDiv /= stringToDouble;
	}

	return currentDiv;

}

/*
 * Allows for debug messages to be turned on or off
 * If no arguments supplied, it will print the current status of debug
 * If one argument supplied <on | off> it will toggle the current status
 * If more than one argument, seek help
 * */
void debugMode(uint8_t argNum, char* argStrings[])
{
	if(argNum < 2)
	{
		printf("##Extended Functionality## \t\t Debug status => %d\n", debugOn);
	}
	else if(argNum > 2)
	{
		printf("Error. Debug command must take zero or one argument. Seek help.\n");
		return;
	}
	else
	{
		char * secondKeyword =  (argStrings)[1];
		if(secondKeyword[0] == 'o' && secondKeyword[1] == 'n' && secondKeyword[2] == '\0')
		{
			if(debugOn == 1)
				printf("Debug is already on.\n");
			else
			{
				debugOn = 1;
				printf("Debug message will be displayed\n");
			}
		}
		else if(secondKeyword[0] == 'o' && secondKeyword[1] == 'f' && secondKeyword[2] == 'f' && secondKeyword[3] == '\0')
		{
			if(debugOn == 0)
				printf("Debug is already off.\n");
			else
			{
				debugOn = 0;
				printf("Debug message will not be displayed");
			}
		}
		else
			printf("Error. Not a valid input for debug keyword. Seek help.");
	}


}

/*
 * Help desk supplies all help information about math functions
 * If no arguments supplied, prints all information about functions
 * If one SPECIFIC math function supplied, prints information about THAT function
 * */
void helpDesk(uint8_t argNum, char* argStrings[])
{
	if(argNum < 2) {
		printf("add <num1> ... <num N> : Sum one or more numbers.\n");
		printf("sub <num1> <num 2> : Subtract two numbers.\n");
		printf("mul <num1> ... <num N> : Multiply one or more numbers.\n");
		printf("div <num1> <num2> : Divide two numbers.\n");
		printf("debug <on|off> : Turn debug messages on or off.\n");
		printf("help [command] : Prints help information for a command\n");

		printf("\n\n##### EXTRA FUNCTIONS #####\n");
		printf("sqrt <num1> : Finds the square root of a double precision floating point number.\n");
		printf("cbrt <num1> : Finds the cube root of a double precision floating point number.\n");
		printf("pow <num1> <num2> : Finds the power of the num1 to the power of num2.\n");
		printf("mod <num1> <num2>: Finds the modulo of two INTEGERS.\n");

	}
	else if(argNum == 2)	{
		char * secondKeyword =  (argStrings)[1];

			if(secondKeyword[0] == 'a' && secondKeyword[1] == 'd' && secondKeyword[2] == 'd' && secondKeyword[3] == '\0')
				printf("add <num1> ... <num N> : Sum one or more numbers.\n");

			else if(secondKeyword[0] == 's' && secondKeyword[1] == 'u' && secondKeyword[2] == 'b' && secondKeyword[3] == '\0')
				printf("sub <num1> <num 2> : Subtract two numbers.\n");

			else if(secondKeyword[0] == 'm' && secondKeyword[1] == 'u' && secondKeyword[2] == 'l' && secondKeyword[3] == '\0')
				printf("mul <num1> ... <num N> : Multiply one or more numbers.\n");

			else if(secondKeyword[0] == 'd' && secondKeyword[1] == 'i' && secondKeyword[2] == 'v' && secondKeyword[3] == '\0')
				printf("div <num1> <num2> : Divide two numbers.\n");
			else if(secondKeyword[0] == 'h' && secondKeyword[1] == 'e' && secondKeyword[2] == 'l' && secondKeyword[3] == 'p' && secondKeyword[4] == '\0')
				printf("help [command] : Prints help information for a command\n");
			else if(secondKeyword[0] == 'd' && secondKeyword[1] == 'e' && secondKeyword[2] == 'b' && secondKeyword[3] == 'u' && secondKeyword[4] == 'g' && secondKeyword[5] == '\0')
				printf("debug <on|off> : Turn debug messages on or off.\n");


			else if(secondKeyword[0] == 's' && secondKeyword[1] == 'q' && secondKeyword[2] == 'r' && secondKeyword[3] == 't' && secondKeyword[4] == '\0')
				printf("sqrt <num1> : Finds the square root of a floating point number.\n");
			else if(secondKeyword[0] == 'c' && secondKeyword[1] == 'b' && secondKeyword[2] == 'r' && secondKeyword[3] == 't' && secondKeyword[4] == '\0')
				printf("cbrt <num1> : Finds the cube root of a floating point number.\n");
			else if(secondKeyword[0] == 'p' && secondKeyword[1] == 'o' && secondKeyword[2] == 'w' && secondKeyword[3] == '\0')
				printf("pow <num1> <num2> : Finds the power of the num1 to the power of num2.\n");
			else if(secondKeyword[0] == 'm' && secondKeyword[1] == 'o' && secondKeyword[2] == 'd' && secondKeyword[3] == '\0')
				printf("mod <num1> <num2>: Finds the modulo of two INTEGERS.\n");


			else
				printf("Error. Unrecognised command. Seek help.\n");
	}
	else
		printf("Error. Unrecognised command. Seek help\n");
}

/*Init method for Command Line - Does nothing important*/
void CommandLineParserInit(void)
{
  // Print welcome message
//  printf("\014"); //this is a form feed
  printf("ELEC3730 Assignment 2\n");
//  printf("Command Line Parser Example\n");
}

/*
 * Continuous looping method
 * If the project is running through WINNT - Builds input string until 'enter' key is inputted
 * If project is running through STM32 (PUTTY) - Builds input string in putty until entered
 *
 * ONE MUST FINISH BEFORE USING THE OTHER AGAIN
 * CANNOT MULTI TYPE AT SAME TIME
 * */
void CommandLineParserProcess(void)
{
  uint8_t c;


  // Check for input and echo back
#ifdef STM32F407xx
  if (HAL_UART_Receive(&huart2, &c, 1, 0x0) == HAL_OK) //code for running through stm board
  {
    HAL_GPIO_TogglePin(GPIOD, LD4_Pin); // Toggle LED4

    	char c;
    	int i;
        char command_line[101];

    	// Get one line of input
    	printf("--> Question 1 - Enter text:\n");
    	i=0;
    	c=getchar(); //keep building
    	while (c != 13 && i < 100) //while enter isnt hit
    	{
    		printf("%c",c); //print to putty and allocate to array
    		command_line[i]=c;
    		i++;
    	    c=getchar();
    	}
    	printf("\n");
    	command_line[i]=0; //done with input, start parsing

    	// Parse the input and print result
      	wordCount = string_parser(command_line, &array_of_words);
      	if(debugOn == 1) printArrayOfWords();
      	analyseKeywords(wordCount, array_of_words);
      	freeEverything();

  }
#else
  c = getchar();
  //printf("SERIAL: Got '%c' or in ascii '%d'\n", c,c);
  buildInputString(c);

#endif
}





/*
 * Builds input string from command line
 * gets char by char and keeps reallocating till finished with input string
 * Once enter is hit, it will begin to parse the string into keywords and begin analysing
 * */
void buildInputString(uint8_t c){
	if(buildInputStringFirstTime == 1)	  {
	  newString = (char*)malloc(sizeof(char*) * length); //start of string. will have reallocation of memory if string is longer
	  buildInputStringFirstTime = 0; //now not the first run through
	  if(c == '\0' || c == 10) {
		  newString[stringIndex] = '\0';

		  wordCount = string_parser(newString, &array_of_words);

		  //printArrayOfWords();
		  //printf("DEBUG: word count -> %d", wordCount);
		  analyseKeywords(wordCount, array_of_words);
		  freeEverything();

		  //printNewString();
		  buildInputStringFirstTime = 1; //reset
		  length = 10;
	  }
	  else{
		  newString[stringIndex] = c;
		  stringIndex++;

	  }

	}
	else{
		newString = (char*)realloc(newString, sizeof(newString)+1);

		if(c == '\0' || c == 10){ //if enter
		  newString[stringIndex] = '\0'; //null terminate string
		  //begin parse
		  wordCount = string_parser(newString, &array_of_words);
		  if(debugOn == 1) printArrayOfWords();
		  //begin analysis of keywords
		  analyseKeywords(wordCount, array_of_words);
		  freeEverything();


		  buildInputStringFirstTime = 1; //reset
		  stringIndex = 0; //reset

		}
		else{
		  newString[stringIndex] = c; //keep appending
		  stringIndex++;
		  if(stringIndex == length) //if string length is maxed out
		  {
			  length *=2; //allocate more memory
			  newString = (char*)realloc(newString,sizeof(char*) * length);
		  }
		}
	}
}

/*
 * String parser from Assignment 1
 * Same as before, goes through string and determines new string without backspaces
 * Loops to determine number of words, number of characters in each word
 * Allocates accordingly
 * */
int string_parser(char *inp, char **array_of_words_p[])
{
	/**********************************SETUP**********************************/

	int numberOfWords = 0;
	int currentWordLength = 0;

	//If input is an empty string, returns straight away
	if(inp[0] == '\0')
		return 0;

	int lengthOfInput = 1; //start from 1 for null terminator
	for(int i = 0; inp[i] != '\0';i++)
		lengthOfInput++;

	//Allocate memory, take into account backspaces for now
	char* convertedInput = (char*)malloc((size_t)lengthOfInput * sizeof(char)); //null terminator

	/**********************************REMOVING BACKSPACES**********************************/
	int reader = 0; //Reading inp variable
	int writer = 0; //Writing to converted Input
	while(inp[reader] != '\0') {
		if(inp[reader] == 127 || inp[reader] == 8) { //backspace char or delete char
			if(writer > 0) //taken into account so the writer isn't being subtracted to a negative index
				writer--;
		}
		else {
			convertedInput[writer] = inp[reader]; //store char from reader into writer
			writer++;
		}
		reader++; //always incrementing writer
	}
	convertedInput[writer] = '\0'; //add null terminator


	/**********************************FIND NUMBER OF WORDS**********************************/
	for(int i = 0; convertedInput[i] != '\0'; i++) { //Iterate until end of the input string
		if(convertedInput[i] != ' ') {
			currentWordLength++;

			//Found a valid character
			if(convertedInput[i+1] == '\0') { //If the next char is the end of the file
				//This gets around the edge case of the for loop stopping when it reaches '\0'
				if(currentWordLength > 0)
					numberOfWords++;
				currentWordLength = 0; //Reset
				continue;
			}

		}
		else {
			//Invalid Character
			if(convertedInput[i-1] == ' ' || convertedInput[i-1] == 127 || convertedInput[i-1] == 8)
				continue;
			else {
				//word is finished
				if(currentWordLength > 0)
					numberOfWords++;
				currentWordLength = 0;
			}
		}
	}

	//allocate single char pointers for number of words
	(*array_of_words_p) = (char**)malloc(sizeof(char*) * (size_t)numberOfWords);


	/**********************************FIND NUMBER OF WORDS**********************************/
	//Reset variables
	currentWordLength = 0;
	int wordIndex = 0; //Used in array indexes
	for(int i = 0; convertedInput[i] != '\0'; i++) {
		if(convertedInput[i] != ' ') { 	//not a space - valid character
			currentWordLength++;

			if(convertedInput[i+1] == '\0' && currentWordLength > 0) {
				//next character is the end, it would not pick up the end of the word
				(*array_of_words_p)[wordIndex] = (char*)malloc(sizeof(char) * (size_t)(currentWordLength + 1)); //Plus 1 is for null terminator
				currentWordLength = 0;
			}
		}
		else {
			//Invalid Character
			if(convertedInput[i-1] == ' ' || convertedInput[i-1] == 127 || convertedInput[i-1] == 8)
				continue;
			else {
				//End of word
				(*array_of_words_p)[wordIndex] = (char*)malloc(sizeof(char) * (size_t)(currentWordLength)+1); //Plus 1 is for null terminator
				wordIndex++;
				currentWordLength = 0;
			}
		}
	}

	/**********************************FIND NUMBER OF LETTERS IN EACH WORD**********************************/
	currentWordLength = 0;
	wordIndex = 0;
	int letterIndex = 0;

	for(int i = 0; convertedInput[i] != '\0'; i++) {
		if(convertedInput[i] != ' ') {
			//valid character
			(*array_of_words_p)[wordIndex][letterIndex] = convertedInput[i];

			letterIndex++;
			if(convertedInput[i+1] == '\0') { //End of string
				(*array_of_words_p)[wordIndex][letterIndex] = '\0';
				wordIndex++;
				letterIndex = 0;
			}
		}
		else {
			//Invalid Character
			if(convertedInput[i-1] == ' ' || convertedInput[i-1] == 127 || convertedInput[i-1] == 8)
				continue;
			else
			{
				//reached end of word
				(*array_of_words_p)[wordIndex][letterIndex] = '\0';
				wordIndex++;
				letterIndex = 0;
			}
		}
	}

	//free the converted input as we do not need it anymore
	free(convertedInput);

	return numberOfWords;
}
//     $Date: 2018-03-26 08:32:18 +1100 (Mon, 26 Mar 2018) $
// $Revision: 1217 $
//   $Author: Peter $

#include "Ass-02.h"
//#include "Ass-02-Q01.c"


//
// PLACE YOUR COMMON CODE HERE 
//

// STEPIEN: Added two touch panel functions to make the interface more
//          consistent with the LCD BSP.

#ifdef STM32F407xx
uint8_t BSP_TP_Init(void)
{
  // Initialise the interface and calibrate
  TP_Init(); // This is an empty function since done by STM32CubeMX
  TouchPanel_Calibrate();

  return 0;
}

uint8_t BSP_TP_GetDisplayPoint(Coordinate *pDisplay)
{
  Coordinate *pScreen;

  pScreen = Read_Ads7846();
  if (pScreen == NULL)
  {
    return 1; // Error reading the touch panel
  }
  if (getDisplayPoint(pDisplay, pScreen, &matrix ) == DISABLE)
  {
    return 1; // Error in LCD
  }
  return 0;
}
#endif
/**
 * ELEC3730 ASSIGNMENT 2
 * QUESTION 2 - CALCULATOR INTERFACE
 * JORDAN HAIGH AND EVAN GRESHAM
 *
 * File takes in user input either from STM32 (Putty) or command line
 * Utilises keywords to perform mathematical functions
 * */
#include "Ass-02.h"

#include "Ass-02-Q01.h"

#include <stdlib.h>

//Button struct necessary for multiple buttons - Form of encapsulating
typedef struct {
	  int startX;
	  int startY;
	  int width;
	  int height;
	  char* text;
	  int id;
}Button;


static Button buttons[20]; //Needed for many loops of calculator
//Text array used for buttons - determined by button id
char *textArray[] = {"7","8","9","del","clr","4","5","6","+","-","1","2","3","/","x","0",".","+-","ans","="};

char* inputString; //input string from user
char* outputString; //output displayed to interface

static int inputStringIndex = 0; //current position of index of string
static int decimalPointPlaced = 0; //limiter for decimal point
static int firstTime = 1; //Used in analyse touch
static int equalsPressed = 0; //Used when outputting to screen that will result will stay till user input again


void CalculatorInit(void); //Initiate calculator for running
void CalculatorProcess(void); //Loop to read calculator inputs

Button buildButton(int x, int y, int w, int h, int id); //Instantiate buttons
int buttonHere(int x, int y, Button button); //Determine if button at X,Y coordinate - return Button ID if true
void showButton(Button button); //Display button on Calculator
void buttonToString(Button button);

void analyseTouch(Button currentButtonPressed);
void concatenateButtonText(char* buttonText);
//double doEquals();
double doEquals2();

int isOperator(char);
int maxSize = 20;
#define MAXINPUTLENGTH 26
static int currentInputLength = 0;

double compute(char operator,char* leftNum,char* rightNum);
char answer[50]; //Getting around malloc bullshit - Other demonstrator (He took over from Lyall for Fri 2-4pm Week 8)
//instructed us to use static arrays rather than malloc for our answers


/**************************Calculator Methods********************************/

/*
 * Initialise calculator methods
 * Set up touch display and begin calibration
 * build buttons and display to screen
 * */
void CalculatorInit(void)
{
  //Assume horizontal display

  // Initialize and turn on LCD and calibrate the touch panel
  BSP_LCD_Init();
  BSP_LCD_DisplayOn();
  BSP_TP_Init();

  // Display welcome message
  BSP_LCD_Clear(LCD_COLOR_WHITE);
  BSP_LCD_SetFont(&Font12);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

  if(debugOn ==1)printf("width = %d\n", (int)BSP_LCD_GetXSize());
  if(debugOn ==1)printf("height = %d\n", (int)BSP_LCD_GetYSize());

  //320 240
  //initialise buttons for screen
  for(int i = 0 ; i < 5; i++)
  {
	  for(int j = 0 ; j < 4 ;j++)
	  {
		  buttons[j * 5 + i] = buildButton(64* i, 80 + 40*j, 64,40,j* 5 + i);
		  showButton(buttons[j*5+i]);
		  buttonToString(buttons[j*5+i]);
	  }
  }
  //Display outputstring in bar at top
  BSP_LCD_SetFont(&Font16);
  BSP_LCD_DisplayStringAt(20,40,"0" ,LEFT_MODE); //init calculator with 0
  strcpy(answer,"0");
}


/*
 * Constant looping method to gather information from user touch
 * */
void CalculatorProcess(void)
{
  //Assume horizontal display

  //Variables used for debouncing issue
	//Debouncing is not perfect, but good enough for purpose of assignment
  static uint8_t fingerTouching = 0;
  static uint8_t bounce = 0;
  static uint8_t offBounce = 0;

  //Now determine which button was pressed on touch screen
  if(BSP_TP_GetDisplayPoint(&display) == 0 && fingerTouching == 0)//0 means valid point on LCD. 1 otherwise(bad coordinate or dodgy LCD)
  {
	  bounce++;
	  if(bounce == 40)
	  {
		  //Once bounced for 40, NOW it realises there is a finer press
		  if(debugOn ==1)printf("Finger on..\n");
		  fingerTouching = 1;
		  bounce = 0;

		  Button currentButtonPressed;
		  //initialise text and id for now. gets around warnings thrown in the below printf.
		  //if an actual button is found, it will update the currentButtonPressed
		  currentButtonPressed.text = "OUTPUT BAR- NOT A BUTTON";
		  currentButtonPressed.id = 999;

		  //go through button array and figure out which button was being pressed
		  for(int i = 0; i < 20;i++)
		  {
			  if(buttonHere(display.x, display.y, buttons[i])!= -1)
			  {
				  if(debugOn ==1)printf("Found button..\n");

				  currentButtonPressed = buttons[i];
			  }
		  }

		  if(debugOn ==1)printf("I am touching the '%s'. ID is %d \n" , currentButtonPressed.text, currentButtonPressed.id);
	      if(debugOn ==1)printf("TOUCH:  Got (%3d,%3d)\n", display.x, display.y);

	      if(currentButtonPressed.id != 999)
	      {
	    	  //Button pressed was a valid button and not the output bar
	    	  analyseTouch(currentButtonPressed);

	    	  //Reset the font and display the answer at the top of the screen
	    	  BSP_LCD_SetFont(&Font16);
	      	  BSP_LCD_DisplayStringAt(20,40,inputString ,LEFT_MODE);
	      }
	  }
  }
  else if(BSP_TP_GetDisplayPoint(&display) == 1)
  {
	  //Finger is not touching the screen

	  offBounce++; //new bouncing variable
	  if(offBounce == 25)
	  {
		  fingerTouching = 0;
		  //printf("Finger off..\n");
	  }
  }
}

/**************************Button Methods********************************/

/*
 * Initialise buttons with startx, starty, width and height. allocate text depending on id that is given
 * */
Button buildButton(int x , int y, int w, int h, int id){
	Button b;
	b.startX = x;
	b.startY = y;
	b.width = w;
	b.height = h;
	b.id = id;

	b.text = textArray[id];

	return b;
}

/*
 * Determine if a button is being pressed at the x y input coordinates
 * If it is able to determine the button that is being pressed, it will return its id
 * Otherwise return -1
 * */
int buttonHere(int x, int y, Button button)
{
	//returns the button id or -1
	if(button.startX  < x &&
			x < button.startX + button.width &&
			button.startY  < y &&
			y < button.startY + button.height)
		return button.id;
	else
		return -1;
}

/*
 * Show button on LCD Screen
 * */
void showButton(Button button){

	BSP_LCD_DrawRect(button.startX, button.startY, button.width, button.height);
	BSP_LCD_SetFont(&Font20);
	BSP_LCD_DisplayStringAt(button.startX + button.width/2,button.startY + button.height/2 -8,button.text,CENTER_MODE);
}


/*
 * Print all button information to string
 * */
void buttonToString(Button button)
{
	if(debugOn == 1)
	{
		printf("Debug: \n");
		printf("Button startX: %d\n", button.startX);
		printf("Button startY: %d\n", button.startY);
		printf("Button width: %d\n", button.width);
		printf("Button height: %d\n", button.height);
		printf("Button text: %s\n", button.text);
		printf("Button id: %d\n", button.id);
	}

}


/************************************************************************/

/*
 * Main analysis method
 * Does plethora of checks
 * If input string is blank -
 * 		If decimal point inputted - extends string
* 		If 0-9 inputted - replaced current string with number
* 		If +,-,/,* inputted, extends string
* 		If +- inputted, does nothing
* 		If clr, equals, del inputted - do nothing
* 	If input string not blank
* 		- If decimal point - make sure previous char is not operator
* 		 - if 0-9 extend string
* 		 if  +,-/,* inputted - make sure that previous char is number. if previous char is oeprator, update that operator
 * */
void analyseTouch(Button currentButtonPressed)
{
	if(debugOn ==1)printf("enter analyse touch\n");
	//https://stackoverflow.com/a/6161123
	if(firstTime == 1)
	{
		//printf("1\n");
		inputString = (char*)realloc(inputString, sizeof(char) * maxSize);
		//printf("1\n");
		strcpy(inputString, "0");  //init
		//printf("1\n");
		//printf("input string starts with %s", inputString);
		firstTime = 0;
		//printf("1\n");

	}

	//In the event that we have pressed equals and keep displaying answer until next button press
    if(equalsPressed == 1)
    {
		equalsPressed = 0;
		strcpy(inputString,"0"); //reset input string
		BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
		BSP_LCD_FillRect(1, 1, 318, 78);
		//revert to black text
		BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
    }

	int buttonId = currentButtonPressed.id;

	if(debugOn ==1)printf("Button id is: %d\n", buttonId);

	char* buttonText = currentButtonPressed.text;
	if(debugOn ==1)printf("Button to text is %s\n\n", buttonText);
//
//	printf("sizeof inputstring %d\n", sizeof(inputString));
//	printf("strlen inputString %d\n\n", strlen(inputString));


	///If working with a blank string
	if(strlen(inputString) == 1 && inputString[0] == '0') //Length 1 and only "0"
	{
		//blank string
		if(debugOn ==1)printf("Recognised strlen of 1 and only a 0\n");

		if(strcmp(buttonText,"0") == 0)
		{
			printf("0 was entered. Nothing to achieve on blank string\n");
			//return;
		}
		else if(strcmp(buttonText, "=") == 0)
		{
			printf("= was entered. Nothing to achieve on blank string\n");
			//return;
		}
		else if(strcmp(buttonText, "clr") == 0)
		{
			printf("clr was entered. Nothing to achieve on blank string\n");
			//return;
		}
		else if(strcmp(buttonText, "1") == 0 ||strcmp(buttonText, "2") == 0 || strcmp(buttonText, "3") == 0 ||
				strcmp(buttonText, "4") == 0 ||strcmp(buttonText, "5") == 0 || strcmp(buttonText, "6") == 0 ||
				strcmp(buttonText, "7") == 0 || strcmp(buttonText, "8") == 0 || strcmp(buttonText, "9") == 0)
		{
			//replace current "0" with another number
			if(debugOn ==1)printf("found %s. replacing current 0\n", buttonText);
			strcpy(inputString, buttonText);
		}
		else if(strcmp(buttonText, ".") == 0)
		{
			concatenateButtonText(buttonText);
			decimalPointPlaced = 1;


		}
		else if(strcmp(buttonText, "+") == 0 || strcmp(buttonText, "-") == 0 ||
				strcmp(buttonText, "/") == 0 || strcmp(buttonText, "x") == 0)
		{
			concatenateButtonText(buttonText);
		}
		else if(strcmp(buttonText, "ans")==0)
		{
			strcpy(inputString, buttonText);
			inputStringIndex =2;
			currentInputLength = strlen(buttonText);
//			concatenateButtonText(buttonText);


		}else if(strcmp(buttonText, "+-") == 0){
			strcpy(inputString, "-0");
			inputStringIndex = 1;
			currentInputLength = strlen(buttonText);


		}

	}
	//We have -0 and want to swap it to -Num instead
	else if(strcmp(inputString,"-0") == 0)
	{
		 if(strcmp(buttonText, "1") == 0 ||strcmp(buttonText, "2") == 0 || strcmp(buttonText, "3") == 0 ||
					strcmp(buttonText, "4") == 0 ||strcmp(buttonText, "5") == 0 || strcmp(buttonText, "6") == 0 ||
					strcmp(buttonText, "7") == 0 || strcmp(buttonText, "8") == 0 || strcmp(buttonText, "9") == 0)
		{
			 inputString[1] = buttonText[0];
		}
		 else if(strcmp(buttonText, "+") == 0 || strcmp(buttonText, "-") == 0 ||
				strcmp(buttonText, "/") == 0 || strcmp(buttonText, "x") == 0)
		{
			concatenateButtonText(buttonText);
		}
		 else if(strcmp(buttonText, "del") == 0)
		 {
			 BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
			 BSP_LCD_FillRect(1, 1, 318, 78);
			 BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

			 inputString[inputStringIndex] = '\0';
			 inputStringIndex = 0;
			 currentInputLength = 1;
		 }
		 else if(strcmp(buttonText,"=") == 0)
		 {
			 double result = doEquals2();

			char resultString [64];
			snprintf(resultString, sizeof(resultString), "%.9lg",result);
			strcpy(inputString, resultString);
			strcpy(answer,resultString);
			//reset variables

			firstTime = 1;
			inputStringIndex = 0;
			decimalPointPlaced = 0;
			BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
			BSP_LCD_FillRect(1, 1, 318, 78);
			BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
			equalsPressed = 1;
			currentInputLength = 0;
		 }
		 else if(strcmp(buttonText,".") == 0)
		 {
			concatenateButtonText(buttonText);
			decimalPointPlaced = 1;
		 }
		 else if(strcmp(buttonText,"0") == 0)
		 {
			 printf("Error. No point adding more zeros \n");
		 }
		 else if(strcmp(buttonText,"+-") == 0)
		 {
			 //reset string back to 0
			 BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
			BSP_LCD_FillRect(1, 1, 318, 78);
			//revert to black text
			BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
			strcpy(inputString,"0");
			inputStringIndex--;
			currentInputLength--;
		 }
		 else if(strcmp(buttonText,"ans") == 0)
		 {
			 printf("Error. Cannot add answer without operator\n");
		 }
		 else if(strcmp(buttonText, "clr") == 0)
		 {
			strcpy(inputString,"0");
			//free(inputString);
			firstTime = 1;
			inputStringIndex = 0;
			decimalPointPlaced = 0;
			currentInputLength = 0;
			//make white rectangle
			BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
			BSP_LCD_FillRect(1, 1, 318, 78);
			//revert to black text
			BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

		 }
		 else
			 printf("Invalid operation - How did you get here?\n");

	}

	//Not a blank string and we enter in a number
	else if(strcmp(buttonText, "0") == 0 || strcmp(buttonText, "1") == 0 || strcmp(buttonText, "2") == 0 ||
			strcmp(buttonText, "3") == 0 || strcmp(buttonText, "4") == 0 || strcmp(buttonText, "5") == 0 ||
			strcmp(buttonText, "6") == 0 || strcmp(buttonText, "7") == 0 || strcmp(buttonText, "8") == 0 ||
			strcmp(buttonText, "9") == 0)
	{
		//append to end of string
		if(inputString[inputStringIndex] == 's'){
			printf("Error can't append a number to answer\n");
		}else{
			concatenateButtonText(buttonText);
		}
	}
	//If decimal point entered
	else if(strcmp(buttonText, ".") == 0)
	{
		//make sure there isnt a decimal point already placed
		if(inputString[inputStringIndex] == 's'){
			printf("Error cannot append decimal point to answer\n");

		}
		else if(decimalPointPlaced == 0)
		{
			//go for it
			concatenateButtonText(buttonText);
			decimalPointPlaced = 1;
		}
		else
		{
			printf("error. already placed decimal point...\n");
			//return;
		}
	}
	//If operation entered
	else if(strcmp(buttonText, "+") == 0 || strcmp(buttonText, "-") == 0 ||
			strcmp(buttonText, "/") == 0 || strcmp(buttonText, "x") == 0)
	{

		//need to check if last char was operator ornumber
		if(debugOn ==1)printf("found +,-,/,*\n");

		char previousChar = inputString[inputStringIndex];
		if(debugOn ==1)printf("comparing char=> %c",previousChar);
		//check that operator is not placed twice in a row
		if((previousChar == '+' && strcmp(buttonText, "+") == 0) ||
				(previousChar == '-' && strcmp(buttonText, "-") == 0) ||
				(previousChar == '/' && strcmp(buttonText, "/") == 0) ||
				(previousChar == 'x' && strcmp(buttonText, "x") == 0))
		{
			//error cant do that mate
			printf("Error. cannot have 2 operators in a row\n");
			return;
		}
		//if previous char is operator and new char is operator
		//replace old operator with new operator
		else if((previousChar == '-' || previousChar == '/' || previousChar == 'x') && strcmp(buttonText,"+") == 0)
		{
			inputString[inputStringIndex] = '+';
			decimalPointPlaced = 0;

		}
		else if((previousChar == '+' || previousChar == '/' || previousChar == 'x') && strcmp(buttonText,"-") == 0)
		{
			inputString[inputStringIndex] = '-';
			decimalPointPlaced = 0;

		}
		else if((previousChar == '+' || previousChar == '-' || previousChar == 'x') && strcmp(buttonText,"/") == 0)
		{
			inputString[inputStringIndex] = '/';
			decimalPointPlaced = 0;

		}
		else if((previousChar == '+' || previousChar == '-' || previousChar == '/') && strcmp(buttonText,"x") == 0)
		{
			inputString[inputStringIndex] = 'x';
			decimalPointPlaced = 0;

		}
		else //add like normal
		{
			//last char was not an operator
			//append new operator to string
			//go for it mate
			concatenateButtonText(buttonText);
			decimalPointPlaced = 0;

		}
	}
	else if(strcmp(buttonText, "=") == 0)
	{
		//cannot parse string if there is an operator at the end of string
		char lastChar = inputString[inputStringIndex];
		if(lastChar == '+' || lastChar ==  '-' || lastChar ==  '/' ||  lastChar == 'x')
		{
			printf("Error. last character is an operator. cannot do equals yet\n");
		}
		else
		{

			double result = doEquals2();

//			strcpy(inputString,"0");
			char resultString [64];
			snprintf(resultString, sizeof(resultString), "%.9lg",result);
			strcpy(inputString, resultString);
			strcpy(answer,resultString);
			//reset variables

			firstTime = 1;
			inputStringIndex = 0;
			decimalPointPlaced = 0;
			BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
			BSP_LCD_FillRect(1, 1, 318, 78);
			BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
			equalsPressed = 1;
			currentInputLength = 0;
//	      	BSP_LCD_DisplayStringAt(20,40,resultString ,LEFT_MODE);

		}
	}
	else if(strcmp(buttonText, "clr") == 0)
	{
		if(debugOn ==1)printf("in clr with non empty string\n");
		//reset variables
		strcpy(inputString,"0");
		//free(inputString);
		firstTime = 1;
		inputStringIndex = 0;
		decimalPointPlaced = 0;
		currentInputLength = 0;
		//make white rectangle
		BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
		BSP_LCD_FillRect(1, 1, 318, 78);
		//revert to black text
		BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

	}
	else if(strcmp(buttonText , "+-") == 0)
	{
		if(inputString[inputStringIndex] == '-' && (inputStringIndex ==0  || isOperator(inputString[inputStringIndex-1]))){
			//the minus we are looking at is for negating a number
			//so we need to remove it
			inputString[inputStringIndex] = '\0';
			inputStringIndex -=1;
			BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
			BSP_LCD_FillRect(1, 1, 318, 78);
			//revert to black text
			BSP_LCD_SetTextColor(LCD_COLOR_BLACK);


		}else if(!isOperator(inputString[inputStringIndex])){
			//the minus needs to be before a number, therefore it needs to be after an operator(or at the start of the string)
			//so error
			//instead of error we need to continue back until the start of the number then insert it there
			int tempPos = inputStringIndex-1;
			while(tempPos >=0 && !isOperator(inputString[tempPos])){
				if(debugOn ==1)printf("tempPos %d\n", tempPos);
				tempPos-=1;
			}
			if(debugOn ==1)printf("final tempPos %d\n", tempPos);

			if(tempPos >=0 && (tempPos ==0 || isOperator(inputString[tempPos-1]))){//if the number is negative
				//take out minus
				for(int i = tempPos ; i< inputStringIndex; i++){
					inputString[i] = inputString[i+1];
				}
				inputString[inputStringIndex] = '\0';
				inputStringIndex -=1;
				BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
				BSP_LCD_FillRect(1, 1, 318, 78);
				//revert to black text
				BSP_LCD_SetTextColor(LCD_COLOR_BLACK);



			}else{
				//now temp pos is pointing to the position in the array before the current number (hopefully)
				//shift everything forward
				for(int i = inputStringIndex; i>tempPos; i--){
					inputString[i+1] = inputString[i];
				}
				inputString[tempPos+1] = '-';
				inputStringIndex +=1;

				inputString[inputStringIndex+1] = '\0';

			}



//			printf("inputStringIndex %d\n", inputStringIndex);
//			printf("previous %c\n", inputString[inputStringIndex]);
//			printf("Error. negative sign needs to be placed before a number\n");
//			return;

		}else{//in every other case we good

			concatenateButtonText("-");


		}

	}
	else if(strcmp(buttonText , "del") == 0){
		BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
		BSP_LCD_FillRect(1, 1, 318, 78);
		BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

		if(inputStringIndex ==0){
			strcpy(inputString,"0");
			firstTime = 1;
			inputStringIndex = 0;
			decimalPointPlaced = 0;

		}else{
			if(isOperator(inputString[inputStringIndex])){
				//printf("1\n");
				//if an operator is deleted then check if the previous number has a decimal
				int tempPos = inputStringIndex -1;
				while(tempPos >=0 && !isOperator(inputString[tempPos])){
					if(inputString[tempPos] == '.'){
						//printf("2\n");
						decimalPointPlaced = 1;
						break;
					}
					tempPos -=1;

				}

			}else if(inputString[inputStringIndex] == '.'){
				decimalPointPlaced =0;

			}else if(inputString[inputStringIndex] == 's'){
				inputString[inputStringIndex] = '\0';
				inputStringIndex -=1;
				inputString[inputStringIndex] = '\0';
				inputStringIndex -=1;
			}

			inputString[inputStringIndex] = '\0';
			inputStringIndex -=1;
			currentInputLength -=1;

		}


	}
	else if(strcmp(buttonText , "ans") == 0){
		if(isOperator(inputString[inputStringIndex])){
			concatenateButtonText(buttonText);
		}else{
			printf("Error can't append answer to a number\n");

		}
	}
	else
	{
		if(debugOn ==1)printf("Hey you pressed a button that doesnt have implementation yet\n");
	}

	if(debugOn ==1)printf("InputStringIndex=> %d\n", inputStringIndex);
	if(debugOn ==1)printf("CurrentInputLength=> %d\n", currentInputLength);
	if(debugOn ==1)printf("Current String=> %s\n", inputString);
}

/*
 * Adds button text to the input string
 * updates size of inputstring if necessary and input string index
 * */
void concatenateButtonText(char* buttonText)
{
	currentInputLength += (int)strlen(buttonText);
	if(currentInputLength > MAXINPUTLENGTH)
	{
		printf("stop. you can't enter any more...\n");
		currentInputLength -=(int)strlen(buttonText);
	}
	else
	{
		if(inputStringIndex + 3 >= maxSize){
			maxSize *= 2;
			inputString = (char*)realloc(inputString, maxSize*sizeof(char));
		}
	//	inputString = realloc(inputString, (inputStringIndex + 2) * sizeof(char));
		strcat(inputString, buttonText);
		inputStringIndex += strlen(buttonText);
		if(debugOn ==1)printf("inputstringindex => %d\n", inputStringIndex);
	}


}

/*
 * Parseing of equation and outputs result
 * 
 * */
double doEquals2(){

	
	if(debugOn ==1)printf("Entering doEquals2()   inputString %s\n", inputString);//if debug on output message
	
	//initiate variables
	int numberOfNumbers = 0;
	int numberOfOperators = 0;
	int lookingAtNumber = 0;//a boolean value used to tell if a you are currently looking at a number 

	//iterate through entire string and find number of operators
	for(int i = 0; i< (int)strlen(inputString); i++){
		if(isOperator(inputString[i]) && lookingAtNumber!= 0){ //if looking at an operator and its not directly after another operator
			numberOfOperators +=1;
			lookingAtNumber =0;
		}else{//if it is a number
			if(lookingAtNumber == 0){//if it is a new number
				numberOfNumbers +=1;
				lookingAtNumber = 1;
			}
		}
	}
	
	//now we can allocate how many numbers we found in the input string
	char numbers[numberOfNumbers][50];
	
	if(numbers == NULL){//malloc error
		printf("Error: malloc failed\n");
		return 0;
	}

	//allocate how many operators we found
	char operators[numberOfOperators];

	//iterate through input string again, this time determining the indexes of number and operator
	int numbersIndex = 0;
	int operatorIndex = 0;
	int startI = 0;

	//add all numbers to the numbers array and add all the operators to the operators array
	for(int i = 0 ;i< (int)strlen(inputString); i++){
		if(isOperator(inputString[i])){
			if(startI <= i-1){//if looking at an operator then add the number which is before it to the array
				strncpy(numbers[numbersIndex], &inputString[startI],i-startI);
				numbers[numbersIndex][i-startI] = '\0';
				
				//if the number is ans or -ans then copy the global variable answer into the array
				if(strcmp("ans", numbers[numbersIndex])==0){
					strcpy(numbers[numbersIndex], answer);
				}
				if(strcmp("-ans", numbers[numbersIndex])==0){

					strcpy(numbers[numbersIndex], "-");
					strcat(numbers[numbersIndex], answer);
					if(numbers[numbersIndex][1] =='-'){//--ans edge case
						if(debugOn ==1)printf("answer %s\n", &answer[1]);
						strcpy(numbers[numbersIndex], &answer[1]);
					}
				}

				//reset counters and iterators
				numbersIndex +=1;
				startI = i+1;

				operators[operatorIndex] = inputString[i];
				operatorIndex +=1;


			}
		}
	}

	//add the last number
	int i = (int)strlen(inputString);

	//add the current number from the input string to the numbers array
	strncpy(numbers[numbersIndex], &inputString[startI],i-startI);
	numbers[numbersIndex][i-startI] = '\0';
	if(strcmp("ans", numbers[numbersIndex])==0){
		strcpy(numbers[numbersIndex], answer);
	}
	if(strcmp("-ans", numbers[numbersIndex])==0){

		strcpy(numbers[numbersIndex], "-");
		strcat(numbers[numbersIndex], answer);
		if(numbers[numbersIndex][1] =='-'){
			strcpy(numbers[numbersIndex], &answer[1]);
		}
	}
	numbersIndex +=1;



	//print all numbers stored and operators stored 
	if(debugOn == 1)printf("numberOfNumbers %d  numberOfOperators %d\n",numberOfNumbers, numberOfOperators);
	for(int i = 0 ; i< numberOfNumbers;i++){
		if(debugOn ==1)printf("numbers %d : %s\n", i,numbers[i]);

	}
	for(int i = 0 ; i< numberOfOperators;i++){
		if(debugOn ==1)printf("operators %d : %c\n", i,operators[i]);

	}



	//order of operations. we're not doing brackets
	char operatorOrder[2][2]= {{'x', '/'},{'+', '-'}};

	for(int operatorGroup = 0; operatorGroup < 2; operatorGroup++){//for each operator grouping
		for(int i = 0; i< numberOfOperators;i++){//for each operator in operator list from input string
			for(int specificOperator = 0; specificOperator < 2; specificOperator++ ){//for each operator in the group
				if(operators[i] == operatorOrder[operatorGroup][specificOperator]){
					//if operator found which matches the one we are looking at
					double result = 0;
					char resultString[64]; //better than using malloc. fuck malloc
					result = compute(operators[i],numbers[i], numbers[i+1]);
					snprintf(resultString, sizeof(resultString), "%.9lg",result);
					if(debugOn ==1)printf("left Number: %s \t operator: %c \t right Number: %s \t result: %s \n", numbers[i], operators[i], numbers[i+1], resultString);


					//now we need to repopulate the numbers and operators array
					for(int j = 0; j< numberOfNumbers-1;j++){
						if(j<i){
							//nothing needs to change

						}else if(j==i){
							//copy the result into the first number used in the operation
							strcpy(numbers[j], resultString);
						}else{
							//move all numbers after the numbers used needs to be moved down
							strcpy(numbers[j], numbers[j+1]);
						}
					}
					numberOfNumbers-=1;
					//every element after the operator used needs to be moved down the array
					for(int j = 0; j< numberOfOperators-1;j++){
						if(j<i){
							//if j < i then we dont need to do anything

						}else if(j>=i){
							//if j >= i then move it down
							operators[j] = operators[j+1];

						}
					}

					numberOfOperators -=1;//we removed an operator

					
					//if there are no operators left then we are done
					if(numberOfOperators ==0){
						
						//convert string result to a double 
						double finalResult =0;
						sscanf(numbers[0],"%lg",&finalResult);
						if(debugOn ==1)printf("finalResult %.9lg\n", finalResult );
						//return the result as a double
						return finalResult;
					}

					//we removed an element of operators so decriment i
					i--;
					break;


				}
			}
		}
	}

	//convert string result to a double 
	double finalResult =0;
	sscanf(numbers[0],"%lg",&finalResult);
	if(debugOn ==1)printf("finalResult %.9lg\n", finalResult );
	//return the result as a double
	return finalResult;
}

/*
 * Determines which operation to apply to two numbers
 * */
double compute(char operator,char* leftNum,char* rightNum){
	/**
	*	Used as reference to commandList[]
	*
	*   {"add",  &validateAddition, "add <num 1> .. <num N>\n"},
	*	{"sub",  &validateSubtraction, "sub <num 1> <num 2>\n"},
	*	{"mul",  &validateMultiplication, "mul <num 1> .. <num N>\n"},
	*	{"div",  &validateDivision, "div <num 1> <num 2>\n"},
	*	{"sqrt", &validateSquareRoot, "sqrt <num1> : Finds the square root of a floating point number.\n"},
	*	{"cbrt", &validateCubeRoot,"cbrt <num1> : Finds the cube root of a floating point number.\n"},
	*	{"pow",  &validatePower,"pow <num1> <num2> : Finds the power of the num1 to the power of num2.\n"},
	*	{"mod",  &validateModulo,"mod <num1> <num2>: Finds the modulo of two INTEGERS.\n"},
	*	{"debug",&debugMode,"debug <on|off> : Turn debug messages on or off.\n"},
	*	{"help", &helpDesk,"help [command] : Prints help information for a command\n"},
	*	{NULL, NULL, NULL}
	**/

	double result = 0;
	char* numbers[3] = {NULL,leftNum,rightNum};
	switch(operator){
	case 'x':
		numbers[0] = commandList[2].nameString; //mul [left] [right].
		result = commandList[2].function_p(3,numbers);
		break;
	case '/':
		numbers[0] = commandList[3].nameString;
		result = commandList[3].function_p(3,numbers);
		break;
	case '+':
		numbers[0] = commandList[0].nameString; //printf("about to add\n");
		result = commandList[0].function_p(3,numbers);
		break;
	case '-':
		numbers[0] = commandList[1].nameString;
		result = commandList[1].function_p(3,numbers);
		break;
	}

	return result;
}

/*
 * Determines if char input is an operator or not
 * Return 1 if true
 * 0 if false
 * */
int isOperator(char input ){
	if(input == 'x' || input == '/' || input == '+' || input == '-'){
		return 1;
	}
	return 0;
}
//     $Date: 2018-03-26 08:32:18 +1100 (Mon, 26 Mar 2018) $
// $Revision: 1217 $
//   $Author: Peter $

#include "Ass-02.h"

//
// REPLACE THE EXAMPLE CODE WITH YOUR CODE 
//

void Ass_02_Main(void)
{
#ifdef STM32F407xx
  uint16_t i=0;
#endif

  // Initialise
  CommandLineParserInit();
#ifdef STM32F407xx
  CalculatorInit();
#endif

  // Loop indefinitely
  while (1)
  {
    CommandLineParserProcess();
#ifdef STM32F407xx
    CalculatorProcess();
#endif

#ifdef STM32F407xx
    if (i++ > 10000)
    {
      HAL_GPIO_TogglePin(GPIOD, LD3_Pin); // Toggle LED3
      i=0;
    }
#endif
  }
}
//     $Date: 2018-03-26 08:32:18 +1100 (Mon, 26 Mar 2018) $
// $Revision: 1217 $
//   $Author: Peter $

// Assignment 2 include file

#ifndef ASS_02_H_
#define ASS_02_H_

// Standard includes
#ifdef STM32F407xx
#include "stm32f4xx_hal.h"
#include "openx07v_c_lcd.h"
#include "touch_panel.h"
#else
#include <windows.h>
#endif
#include <stdio.h>
#include <stdint.h>
#include <malloc.h>
#include <string.h>

// Assignment main
extern void Ass_02_Main(void);

//
// REPLACE THE EXAMPLE CODE WITH YOUR CODE 
//

// Question 1
extern void CommandLineParserInit(void);
extern void CommandLineParserProcess(void);

// Question 2
extern void CalculatorInit(void);
extern void CalculatorProcess(void);

// Library functions
#ifdef STM32F407xx
extern uint8_t BSP_TP_Init(void);
extern uint8_t BSP_TP_GetDisplayPoint(Coordinate *pDisplay);
#endif

#endif /* ASS_02_H_ */
/**
 * ELEC3730 ASSIGNMENT 2
 * QUESTION 1 - COMMAND LINE PARSER
 * JORDAN HAIGH AND EVAN GRESHAM
 * HEADER FILE
 *
 * File takes in user input either from STM32 (Putty) or command line
 * Utilises keywords to perform mathematical functions
 * */





void buildInputString(uint8_t c);
int string_parser(char *inp, char **array_of_words_p[]);
void analyseKeywords(uint8_t argNum, char* argStrings[]);


uint8_t checkForNumericArgument2(uint8_t processingIntegerFlag, uint8_t argNum, char* argStrings[]);
uint8_t checkArgumentLength2(uint8_t flag, uint8_t expectedWordCount, uint8_t argNum);

double validateAddition(uint8_t argNum, char* argStrings[]);
double addNumbers(uint8_t argNum, char* argStrings[]);
double validateSubtraction(uint8_t argNum, char* argStrings[]);
double subNumbers(uint8_t argNum, char* argStrings[]);
double validateMultiplication(uint8_t argNum, char* argStrings[]);
double mulNumbers(uint8_t argNum, char* argStrings[]);
double validateDivision(uint8_t argNum, char* argStrings[]);
double divNumbers(uint8_t argNum, char* argStrings[]);

void debugMode(uint8_t argNum, char* argStrings[]);
void helpDesk(uint8_t argNum, char* argStrings[]);

double validateAndRunRoot(uint8_t flag, uint8_t argNum, char* argStrings[]);
double validateSquareRoot(uint8_t argNum, char* argStrings[]);
double validateCubeRoot(uint8_t argNum, char* argStrings[]);
double squareRoot(char* argStrings[]);
double cubeRoot(char* argStrings[]);
double validatePower(uint8_t argNum, char* argStrings[]);
double power(char* argStrings[]);
double validateModulo(uint8_t argNum, char* argStrings[]);
int modulo(char* argStrings[]);

#ifndef MESTRUCT
#define MESTRUCT
typedef struct
{
	char* nameString; //command string
	double (*function_p)(uint8_t argNum, char* argStrings[]); //function pointer
	char* helpString; //help message
} command_s;
#endif

//Global variables to be used in Q1 and in Q2
const command_s commandList[11];
uint8_t debugOn;


//     $Date: 2018-03-26 08:32:18 +1100 (Mon, 26 Mar 2018) $
// $Revision: 1217 $
//   $Author: Peter $

// Assignment 2 include file

#ifndef ASS_02_H_
#define ASS_02_H_

// Standard includes
#ifdef STM32F407xx
#include "stm32f4xx_hal.h"
#include "openx07v_c_lcd.h"
#include "touch_panel.h"
#else
#include <windows.h>
#endif
#include <stdio.h>
#include <stdint.h>
#include <malloc.h>
#include <string.h>

// Assignment main
extern void Ass_02_Main(void);

//
// REPLACE THE EXAMPLE CODE WITH YOUR CODE 
//

// Question 1
extern void CommandLineParserInit(void);
extern void CommandLineParserProcess(void);

// Question 2
extern void CalculatorInit(void);
extern void CalculatorProcess(void);

// Library functions
#ifdef STM32F407xx
extern uint8_t BSP_TP_Init(void);
extern uint8_t BSP_TP_GetDisplayPoint(Coordinate *pDisplay);
#endif

#endif /* ASS_02_H_ */
